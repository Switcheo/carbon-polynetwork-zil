scilla_version 0

import Conversions PairUtils ListUtils NatUtils

(* See: https://github.com/polynetwork/eth-contracts/blob/2.0/contracts/core/cross_chain_manager/logic/EthCrossChainManagerImplementation.sol *)

(***************************************************)
(*               Associated library                *)
(***************************************************)

library ZilCrossChainManagerV2

let true = True
let false = False
let zero_amt = Uint128 0
let one = Uint256 1
let none = None {ByStr20}
let big_endian = BigEndian
let padding = let x = 0x00 in builtin to_bystr x
let nil_address = 0x0000000000000000000000000000000000000000
let empty_abi_encoded_string = 0x000000000000000000000000000000000000000000000000000000000000000000000000
let zion_ccm_address = 0x5747C05FF236F8d18BB21Bc02ecc389deF853cae
let address_list_length = @list_length ByStr20

let zilliqa_chain_id = Uint64 88
let zion_seal_length = Uint32 67     (* rlpPrefix: 2 , r: 32 , s:32 , v:1 *)
let zion_peer_length = Uint32 93     (* rlpPrefix: 2 , pk_rlp: 70 , address_rlp: 21 *)
let zion_address_length = Uint32 21  (* rlpPrefix: 1 , address: 20 *)

(* byte constants *)
let u0x00 = Uint32 0
let u0x01 = Uint32 1
let u0x02 = Uint32 2
let u0x03 = Uint32 3
let u0x08 = Uint32 8
let u0x0c = Uint32 12
let u0x14 = Uint32 20
let u0x1f = Uint32 31
let u0x20 = Uint32 32
let u0x40 = Uint32 64
let u0x80 = Uint32 128
let u0xb6 = Uint32 182
let u0xb7 = Uint32 183
let u0xc0 = Uint32 192
let u0xd7 = Uint32 215
let u0xe0 = Uint32 224
let u0xf6 = Uint32 246
let u0xf7 = Uint32 247
let u0x117 = Uint32 279

(* Error events *)
type Error =
  | CodeNotOwner
  | CodeNotPendingOwner
  | CodeAlreadyInitialized
  | CodeNoValidatorsInHeader
  | CodeHeaderVerificationFailed
  | CodeInvalidBlockHeight
  | CodeInvalidTxHash
  | CodeInvalidToChainID
  | CodeInvalidToContract
  | CodeTxAlreadyExecuted

let make_error =
  fun (result : Error) =>
    let result_code =
      match result with
      | CodeNotOwner                  => Int32 -1
      | CodeNotPendingOwner           => Int32 -2
      | CodeAlreadyInitialized        => Int32 -3
      | CodeNoValidatorsInHeader      => Int32 -4
      | CodeHeaderVerificationFailed  => Int32 -5
      | CodeInvalidBlockHeight        => Int32 -6
      | CodeInvalidTxHash             => Int32 -7
      | CodeInvalidToChainID          => Int32 -8
      | CodeInvalidToContract         => Int32 -9
      | CodeTxAlreadyExecuted         => Int32 -10
      end
    in
    { _exception : "Error"; code : result_code }

let one_msg =
  fun (msg : Message) =>
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

(* Zion header parsing *)

type Header =
  | Header of ByStr Uint256 (* root, number *)

let get_number : Header -> Uint256 =
  fun (h : Header) =>
  match h with
  | Header root number =>
    number
  end

(* Cross chain tx params *)
type TxParam =
  | TxParam of
    ByStr  (* source chain txHash *)
    ByStr  (* crossChainId *)
    ByStr  (* fromContract *)
    Uint64 (* toChainId *)
    ByStr  (* toContract *)
    ByStr  (* method *)
    ByStr  (* args *)


type CrossTx =
  | CrossTx of
    ByStr   (* zion txHash *)
    Uint64  (* fromChainId *)
    TxParam (* cross chain tx param *)

(* converts a Uint32 to a Uint256 *)
let grow : Uint32 -> Uint256 =
  fun (var : Uint32) =>
    let maybe_big = builtin to_uint256 var in
    match maybe_big with
    | Some big => big
    | None => Uint256 0 (* should never happen: u32->u256 *)
    end

(* extracts the address from Pair (address, offset) *)
let get_address : Pair ByStr20 Uint32 -> ByStr20 = @fst ByStr20 Uint32

(* extracts the data from Pair (data, offset) *)
let get_data : Pair ByStr Uint32 -> ByStr = @fst ByStr Uint32

(* extracts the size from Pair (size, offset) *)
let get_size : Pair Uint32 Uint32 -> Uint32 = @fst Uint32 Uint32

(* extracts the offset from Pair (size, offset) *)
let get_offset : Pair Uint32 Uint32 -> Uint32 = @snd Uint32 Uint32

(* extracts the size + offset from Pair (size, offset) *)
let get_data_offset : Pair Uint32 Uint32 -> Uint32 =
  fun (pair : Pair Uint32 Uint32) =>
    match pair with
    | Pair size offset => builtin add size offset
    end

(* left pads a byte string with 0s *)
let pad : ByStr -> Uint32 -> ByStr =
  fun (buffer : ByStr) =>
  fun (required_length : Uint32) =>
    let current_length = builtin strlen buffer in
    let padding_length = builtin sub required_length current_length in
    let fold = @nat_fold ByStr in
    let fn = fun (cur : ByStr) => fun (num : Nat) => builtin concat padding cur in
    let count = builtin to_nat padding_length in
    fold fn buffer count

(* right pad bytes with 0s such that it is a multiple of 32 bytes (u255) *)
let pad_bytes: ByStr -> ByStr =
  fun (bz : ByStr) =>
    let data_length = builtin strlen bz in
    let padding_length = builtin rem data_length u0x20 in
    let fold = @nat_fold ByStr in
    let fn = fun (cur : ByStr) => fun (num : Nat) => builtin concat cur padding in
    let count = builtin to_nat padding_length in
    fold fn bz count

let rlp_read_kind: ByStr -> Uint32 -> Pair Uint32 Uint32 =
    fun (raw : ByStr) =>
    fun (offset : Uint32) =>
      (*
        assembly {
            k := shr(0xf8,mload(add(raw,offset)))
            // shift word at position offset in raw by 0xf8 (248 bits)
            // => i.e. remove last 248 bits and read the first 256-248 = 8 bits = 1 byte
        }
      *)
      let res = extract_bystr1 raw offset in
      match res with
      | None =>
        (* ERR! just blow up here *)
        let exception_code = Uint32 1001 in (* make this err easy to find *)
        let size = builtin sub u0x00 exception_code in
        Pair {Uint32 Uint32} size offset
      | Some pair =>
        match pair with
        | Pair k_bystr _ =>
          let k = builtin to_uint32 k_bystr in
          let lt_0x80 = builtin lt k u0x80 in
          let lt_0xb7 = builtin lt k u0xb7 in
          let lt_0xc0 = builtin lt k u0xc0 in
          let lt_0xf7 = builtin lt k u0xf7 in
          match lt_0x80 with | True =>
          (*
            if (k<0x80) {
                assembly {
                    size := 1
                    offset_ := offset
                }
                return (size,offset_);
            }
          *)
            let size = u0x01 in
            Pair {Uint32 Uint32} size offset | False =>
          match lt_0xb7 with | True =>
            (*
              if (k<0xb7) {
                  assembly {
                      size := sub(k,0x80)
                      offset_ := add(offset,1)
                  }
                  return (size,offset_);
              }
            *)
            let size = builtin sub k u0x80 in
            let next_offset = builtin add offset u0x01 in
            Pair {Uint32 Uint32} size next_offset | False =>
          match lt_0xc0 with | True =>
            (*
              if (k<0xc0) {
                  assembly {
                      size := shr(mul(8,sub(0xd7,k)),mload(add(add(raw,offset),0x01)))
                      // the value is at raw + offset + 1. note shr is in bits but mload is in bytes
                      // shift is 8*(0xd7 - k) => this determines how many bytes to read in for the size
                      // => this can be from 23 to 32 bytes
                      // so we just need to cut the raw bystr from (offset + 1) to (0xd7 - k) and convert it to a uint32
                      offset_ := add(offset,sub(k,0xb6))
                      // next offset is offset + (k - 0xb6)
                  }
                  return (size,offset_);
              }
            *)
            let idx = builtin add offset u0x01 in
            let len = builtin sub u0xd7 k in (* we don't have to multiply by 8 here, as len is in bytes *)
            let size_bz = builtin substr raw idx len in
            let size_bz_padded = pad size_bz u0x20 in (* must be 32 bytes long for proper extraction *)
            let size = extract_uint32 big_endian size_bz_padded u0x00 in
            match size with
            | None =>
              (* ERR! just blow up here *)
              let exception_code = Uint32 1002 in (* make this err easy to find *)
              let s = builtin sub u0x00 exception_code in
              Pair {Uint32 Uint32} s offset
            | Some p => match p with | Pair s _ =>
              let next_offset = let x = builtin sub k u0xb6 in builtin add x offset in
              Pair {Uint32 Uint32} s next_offset
            end end | False =>
          match lt_0xf7 with | True =>
            (*
              if (k<0xf7) {
                  assembly {
                      size := sub(k,0xc0)
                      offset_ := add(offset,1)
                  }
                  return (size,offset_);
              }
            *)
            let size = builtin sub k u0xc0 in
            let next_offset = builtin add offset u0x01 in
            Pair {Uint32 Uint32} size next_offset
          | False =>
            (*
              {
                  assembly {
                      size := shr(mul(8,sub(0x117,k)),mload(add(add(raw,offset),0x01)))
                      // the value is at raw + offset + 1. note shr is in bits but mload is in bytes
                      // shift is 8*(0x117 - k) => this determines how many bytes to read in for the size
                      // => this can be from 14 to 31 bytes
                      // so we just need to cut the bystr from (offset + 1) to (0x117 - k) and convert it to a uint32
                      offset_ := add(offset,sub(k,0xf6))
                      // next offset is offset + (k - 0xf6)
                  }
              }
            *)
            let idx = builtin add offset u0x01 in
            let len = builtin sub u0x117 k in (* we don't have to multiply by 8 here, as len is in bytes *)
            let size_bz = builtin substr raw idx len in
            let size_bz_padded = pad size_bz u0x20 in (* must be 32 bytes long for proper extraction *)
            let size = extract_uint32 big_endian size_bz_padded u0x00 in
            match size with
            | None =>
              (* ERR! just blow up here *)
              let exception_code = Uint32 1003 in (* make this err easy to find *)
              let s = builtin sub u0x00 exception_code in
              Pair {Uint32 Uint32} s offset
            | Some p => match p with | Pair s _ =>
              let next_offset = let x = builtin sub k u0xf6 in builtin add x offset in
              Pair {Uint32 Uint32} s next_offset
            end end
          end
          end
          end
          end
        end
      end

(* NOTE: do NOT use `raw` with offset < returned offset as it has not been modified. *)
let rlp_split : ByStr -> Uint32 -> Pair ByStr Uint32 =
  fun (raw : ByStr) =>
  fun (offset : Uint32) =>
    (*
      uint size;
      (size,offset_) = rlpReadKind(raw,offset);
      // [offset_,...offset_+size]
      assembly {
          mstore(add(raw,sub(offset_,0x20)),size)
          // write size into the 32 bytes before the data
          // [offset_-32,...,offset_,...,offset_+size]
          res := add(raw,sub(offset_,0x20))
          // return next offset starting from the size
          // [res,...,offset_,...,offset_+size]
          offset_ := add(offset_,size)
          // replace offset_ to end
          // [res,...,o,...,offset_,...]
      }
    *)
    let p = rlp_read_kind raw offset in
    match p with
    | Pair size data_offset =>
      (* pad size to 32 bytes *)
      let len = builtin strlen raw in
      let data_len = builtin sub len data_offset in
      let size_bz_fixed = builtin to_bystr4 size in
      let size_bz = builtin to_bystr size_bz_fixed in
      let size_bz_padded = pad size_bz u0x20 in
      let data_bz = builtin substr raw data_offset data_len in
      let res_bz = builtin concat size_bz_padded data_bz in
      let next_offset = builtin add size data_offset in
      Pair {ByStr Uint32} res_bz next_offset
    end

let rlp_get_next_bytes : ByStr -> Uint32 -> Pair ByStr Uint32 =
  fun (raw : ByStr) =>
  fun (offset : Uint32) =>
    (*
      uint size;
      (size,offset) = rlpReadKind(raw, offset);
      _offset = size + offset;
    *)
    let p = rlp_read_kind raw offset in
    match p with
    | Pair size data_offset =>
      let new_offset = builtin add size data_offset in
      (*
        assembly {
            res := mload(0x40)
            // load the nxt free memory addr
            let alloc := add(0x20, mul(0x20, div(add(size,0x1f), 0x20)))
            // required alloc is 32 + 32*((size+31)/32), i.e. (size in bytes rounded up to nearest word (32 bytes / 256 bits) + 1) word
            mstore(0x40, add(res,alloc))
            // move the nxt free memory addr by alloc bits
            mstore(res,size)
            // put 1 byte size at the start of buffer
            pop(staticcall(gas(),0x4,add(raw,offset), size, add(res,0x20), size))
            // call datacopy precompiled contract (0x4) contract with in=(raw+offset), insize=size, out=nxt free addr, outsize=size
            // so all this basically just puts [...size, sizebytes] into res
        }
      *)
      let size_u256 = grow size in
      let size_bz_fixed = builtin to_bystr32 size_u256 in (* size occupies 1 word *)
      let size_bz = builtin to_bystr size_bz_fixed in
      let data_bz = builtin substr raw data_offset size in
      let required_size = let x = builtin add size u0x1f in let y = builtin div x u0x20 in let z = builtin add y u0x01 in builtin mul z u0x20 in
      let data_bz_padded = pad data_bz required_size in
      let bz = builtin concat size_bz data_bz_padded in
      Pair {ByStr Uint32} bz new_offset
    end

let rlp_get_next_uint256 : ByStr -> Uint32 -> Pair Uint256 Uint32 =
  fun (raw : ByStr) =>
  fun (offset : Uint32) =>
    (*
      uint size;
      (size,offset) = rlpReadKind(raw, offset);
      require(size<=32,"rlpGetNextUint256: data longer than 32 bytes");
      // this is auto-checked with builtin sub
      _offset = size + offset;
      assembly {
          let pad := sub(0x20,size)
          // padding is 32 - size
          res := shr(mul(pad,8), shl(mul(pad,8), mload(add(raw,sub(offset,pad)))))
          // load word at (offset - pad), meaning there is pad bytes worth of useless data on the left
          // then shift left then shift right by pad bytes, i.e. this zeroes out pad bytes on the left
      }
    *)
    let p = rlp_read_kind raw offset in
    match p with
    | Pair size data_offset =>
      (* we just read the required size and pad left to 0x20 *)
      let bz = builtin substr raw data_offset size in
      let bz_padded = pad bz u0x20 in
      let bz_fixed = builtin to_bystr32 bz_padded in
      match bz_fixed with
      | None =>
        (* just blow up, should never happen *)
        let exception_code = Uint256 1004 in (* make this err easy to find *)
        let z = Uint256 0 in
        let value = builtin sub z exception_code in
        Pair {Uint256 Uint32} value data_offset
      | Some b =>
        let value = builtin to_uint256 b in
        let next_offset = builtin add size data_offset in
        Pair {Uint256 Uint32} value next_offset
      end
    end

let rlp_get_next_uint64 : ByStr -> Uint32 -> Pair Uint64 Uint32 =
  fun (raw : ByStr) =>
  fun (offset : Uint32) =>
    (*
      // same as rlp_get_next_uint256 except size check
      uint size;
      (size,offset) = rlpReadKind(raw, offset);
      require(size<=8,"rlpGetNextUint64: data longer than 8 bytes");
      _offset = size + offset;
      assembly {
          let pad := sub(0x20,size)
          res := shr(mul(pad,8), shl(mul(pad,8), mload(add(raw,sub(offset,pad)))))
      }
    *)
    let r = rlp_get_next_uint256 raw offset in
    match r with
    | Pair i o =>
      let small = builtin to_uint64 i in
      match small with
      | None =>
        (* size check for require(size<=8,"rlpGetNextUint64: data longer than 8 bytes"); *)
        let exception_code = Uint64 1005 in (* make this err easy to find *)
        let z = Uint64 0 in
        let value = builtin sub z exception_code in
        Pair {Uint64 Uint32} value o
      | Some u64 =>
        Pair {Uint64 Uint32} u64 o
      end
    end

let rlp_get_next_address : ByStr -> Uint32 -> Pair ByStr20 Uint32 =
  fun (raw : ByStr) =>
  fun (offset : Uint32) =>
  (*
    uint size;
    (size,offset) = rlpReadKind(raw, offset);
    require(size<=0x14,"rlpGetNextAddress: data longer than 20 bytes");
    _offset = size + offset;
    assembly {
        let pad := sub(0x20,size)
        res := shr(mul(pad,8), shl(mul(pad,8), mload(add(raw,sub(offset,pad)))))
        // load size bytes into a 32 byte buffer, padding the left bytes with zeroes
        // (see: same as in rlp_get_next_uint256 above)
    }
  *)
  let p = rlp_read_kind raw offset in
  match p with
  | Pair size data_offset =>
    let check = builtin sub u0x14 size in
    let bz = builtin substr raw data_offset u0x20 in
    let bz_padded = pad bz u0x20 in
    let m = builtin to_bystr20 bz_padded in
    match m with
    | None =>
        (* ERR! just blow up here *)
        let exception_code = Uint32 1006 in (* make this err easy to find *)
        let next_offset = builtin sub u0x00 exception_code in
        Pair {ByStr20 Uint32} nil_address next_offset
    | Some bz_fixed =>
      let next_offset = builtin add size offset in
      Pair {ByStr20 Uint32} bz_fixed next_offset
    end
  end

let decode_header : ByStr -> Header =
  fun (rawHeader : ByStr) =>
  (*
    (,uint offset) = rlpReadKind(rawHeader,0x20);
    (header.root,) = rlpGetNextBytes(rawHeader, offset + 87); // position of Root
    (size,offset) = rlpReadKind(rawHeader, offset + 445); // position of Difficulty
    (header.number,) = rlpGetNextUint256(rawHeader, offset + size);  // position of Number
  *)
    let p1 = rlp_read_kind rawHeader u0x20 in
    let offset = get_offset p1 in
    let o2 = let x = Uint32 87 in builtin add offset x in
    let p2 = rlp_get_next_bytes rawHeader o2 in
    match p2 with
    | Pair root _ =>
      let o3 = let x = Uint32 445 in builtin add offset x in
      let p3 = rlp_read_kind rawHeader o3 in
      match p3 with
      | Pair size offset2 =>
        let o4 = builtin add offset2 size in
        let p4 = rlp_get_next_uint256 rawHeader o4 in
        match p4 with
        | Pair number _ =>
          Header root number
        end
      end
    end

let get_validators_from_header : ByStr -> List ByStr20 =
  fun (rawHeader : ByStr) =>
  (*
    (,uint offset) = rlpReadKind(rawHeader,0x20);
    (size,offset) = rlpReadKind(rawHeader, offset + 445 ); // position of Difficulty
    (size,offset) = rlpReadKind(rawHeader, offset + size); // position of Number
    (size,offset) = rlpReadKind(rawHeader, offset + size); // position of GasLimit
    (size,offset) = rlpReadKind(rawHeader, offset + size); // position of GasUsed
    (size,offset) = rlpReadKind(rawHeader, offset + size); // position of Time
    (bytes memory extra,) = rlpGetNextBytes(rawHeader, offset + size);
    (bytes memory validatorsBytes,) = rlpGetNextBytes(extra, 0x40);
    (size, offset) = rlpReadKind(validatorsBytes, 0x20);
    require(size%ZION_ADDRESS_LEN==0,"invalid header extra validatorSet");
    validators = new address[](size/ZION_ADDRESS_LEN);
    for (uint i = 0; i*ZION_ADDRESS_LEN<size; i++) {
        (address valAddr,) = rlpGetNextAddress(validatorsBytes, offset + i*ZION_ADDRESS_LEN);
        validators[i] = valAddr;
    }
  *)
  let p1 = rlp_read_kind rawHeader u0x20 in
  let p2 = let o1 = get_offset p1 in
           let u445 = Uint32 445 in
           let o = builtin add u445 o1 in rlp_read_kind rawHeader o in (* position of Difficulty *)
  let p3 = let o = get_data_offset p2 in rlp_read_kind rawHeader o in (* position of Number *)
  let p4 = let o = get_data_offset p3 in rlp_read_kind rawHeader o in (* position of GasLimit *)
  let p5 = let o = get_data_offset p4 in rlp_read_kind rawHeader o in (* position of GasUsed *)
  let p6 = let o = get_data_offset p5 in rlp_read_kind rawHeader o in (* position of Time *)
  let extra = let o = get_data_offset p6 in let b = rlp_get_next_bytes rawHeader o in get_data b in
  let val_bz = let b = rlp_get_next_bytes extra u0x40 in get_data b in
  let p = rlp_read_kind val_bz u0x20 in
  match p with
  | Pair size offset =>
    let check = builtin rem size zion_address_length in
    let throw_if_not_zero = builtin sub u0x00 check in
    let length = builtin div size zion_address_length in
    let initial = Nil {ByStr20} in
    let count = builtin to_nat length in
    let fold = @nat_fold (List ByStr20) in
    let fn = fun (cur : List ByStr20) => fun (num : Nat) =>
      let i = nat_to_int num in
      let o = let n = builtin mul i zion_address_length in builtin add offset n in
      let r = rlp_get_next_address val_bz o in
      let val = get_address r in
      Cons {ByStr20} val cur
    in
    (* array is constructed by pushing to the head of list - reverse to maintain right order *)
    let array = fold fn initial count in
    let reverse = @list_reverse ByStr20 in
    reverse array
  end

let has_enough_signers : List ByStr20 -> List ByStr20 -> Bool =
  fun (validators : List ByStr20) =>
  fun (signers : List ByStr20) =>
    (*
        uint _m = _validators.length.mul(2).div(3).add(1);
        bool[] memory _checked = new bool[](_validators.length);
        uint m = 0;
        for(uint i = 0; i < _signers.length; i++){
            for (uint j = 0; j < _validators.length; j++) {
                if (!_checked[j] && _signers[i]==_validators[j]) {
                    m++;
                    _checked[j] = true;
                    break;
                }
            }
        }
        return m >= _m;
    *)
    let val_count = address_list_length validators in
    let required = let x = builtin mul val_count u0x02 in let y = builtin div x u0x03 in builtin add y u0x01 in
    let acc = Pair {(List ByStr20) Uint32} signers u0x00 in (* unused signers, valid signature count *)
    let fold = @list_foldl ByStr20 (Pair (List ByStr20) Uint32) in
    let fold_fn = fun (acc : Pair (List ByStr20) Uint32) => fun (validator : ByStr20) =>
      match acc with
      | Pair remaining_signers signed_count =>
        let finder = @list_exists ByStr20 in
        let equality_fn = fun (signer : ByStr20) => builtin eq signer validator in
        let found = finder equality_fn signers in
        match found with
        | True =>
          (* NOTE: here we assume that all validators are unique, which should be ok? *)
          let filter = @list_filter ByStr20 in
          let new_remaining_signers = filter equality_fn remaining_signers in
          let new_count = builtin add signed_count u0x01 in
          Pair {(List ByStr20) Uint32} new_remaining_signers new_count
        | False => acc (* no change if not found *)
        end
      end
    in
    let res = fold fold_fn acc validators in
    match res with
    | Pair _ matched =>
      let insufficient = builtin lt required matched in
      match insufficient with
      | True => False
      | False => True
      end
    end

let verify_seal : ByStr32 -> ByStr -> ByStr20 =
  fun (sigHash : ByStr32) =>
  fun (seal : ByStr) =>
    (*
      function verifySeal(bytes32 sigHash, bytes memory seal) internal pure returns(address signer) {
          if (seal.length != 65) {
              return (address(0));
          }

          bytes32 r;
          bytes32 s;
          uint8 v;

          assembly {
              r := mload(add(seal, 0x20))
              s := mload(add(seal, 0x40))
              v := add(27, byte(0, mload(add(seal, 0x60))))
          }

          // uncomment codes below if needed
          // if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
          //     return address(0);
          // }

          // if (v != 27 && v != 28) {
          //     return address(0);
          // }

          return ecrecover(sigHash, v, r, s);
      }
    *)
    let rs = builtin substr seal u0x00 u0x40 in
    let m1 = builtin to_bystr64 rs in
    match m1 with
    | None => nil_address (* shld never happen. nil addr === fail *)
    | Some sig =>
      let v = builtin substr seal u0x40 u0x01 in
      let m2 = builtin to_bystr1 v in
      match m2 with
      | None => nil_address (* shld never happen. nil addr === fail *)
      | Some v_fixed =>
        let data = builtin to_bystr sigHash in
        let recid = builtin to_uint32 v_fixed in
        let pk = builtin ecdsa_recover_pk data sig recid in
        let hash = builtin keccak256hash pk in
        let hash_bz = builtin to_bystr hash in
        let addr_bz = builtin substr hash_bz u0x0c u0x14 in (* address is last 20 bytes of pk hash, idx: 32 - 20 = 12 => u0x0c *)
        let a = builtin to_bystr20 addr_bz in
        match a with
        | None => nil_address (* shld never happen. nil addr === fail *)
        | Some addr => addr
        end
      end
    end

let verify_header : ByStr32 -> ByStr -> List ByStr20 -> Bool =
  fun (headerHash : ByStr32) =>
  fun (rawSeals : ByStr) =>
  fun (validators : List ByStr20) =>
    (*
      uint offset = 0x20;
      bytes memory seal;

      (rawSeals,) = rlpSplit(rawSeals, 0x20);
      uint sealCount = rawSeals.length.div(ZION_SEAL_LEN);
      address[] memory signers = new address[](sealCount);

      for (uint i=0; i<sealCount; i++) {
          (seal,offset) = rlpSplit(rawSeals, offset);
          signers[i] = verifySeal(keccak256(abi.encodePacked(headerHash)), seal);
          if (signers[i] == address(0)) {
              return false;
          }
      }
      return hasEnoughSigners(validators, signers);
    *)
    let p = rlp_split rawSeals u0x20 in
    let raw_seals_data = get_data p in
    let raw_seals_len = builtin strlen raw_seals_data in
    let seal_count = builtin div raw_seals_len zion_seal_length in
    let count = builtin to_nat seal_count in
    let signers = Nil {ByStr20} in
    let acc = Pair {(List ByStr20) Uint32} signers u0x00 in
    let fold = @nat_fold (Pair (List ByStr20) Uint32) in
    let fn = fun (cur : Pair (List ByStr20) Uint32) => fun (num : Nat) =>
      match cur with
      | Pair signers offset =>
        let p1 = rlp_split raw_seals_data offset in
        match p1 with
        | Pair seal new_offset =>
          let hash = builtin keccak256hash headerHash in
          let signer = verify_seal hash seal in
          let new_list = Cons {ByStr20} signer signers in
          Pair {(List ByStr20) Uint32} new_list new_offset
        end
      end
    in
    let res = fold fn acc count in
    match res with
    | Pair list _ =>
      has_enough_signers validators list
    end

let abi_encode_length : Uint32 -> ByStr =
  fun (i : Uint32) =>
    let bz_fixed = builtin to_bystr4 i in
    let bz = builtin to_bystr bz_fixed in
    pad bz u0x20

let append_abi_encoded_length : ByStr -> Uint32 -> ByStr =
  fun (buffer : ByStr) =>
  fun (i : Uint32) =>
    let bz = abi_encode_length i in
    builtin concat buffer bz

let abi_encode_bytes : ByStr -> ByStr =
  fun (bz : ByStr) =>
    let len = builtin strlen bz in
    let len_bz = abi_encode_length len in
    let data_bz = pad_bytes bz in
    builtin concat len_bz data_bz

let next_offset : Uint32 -> ByStr -> Uint32 =
  fun (current_offset : Uint32) =>
  fun (bz : ByStr) =>
    let len = builtin strlen bz in
    builtin add current_offset len

let encode_tx_param =
  fun (txHash : ByStr) =>
  fun (crossChainId : ByStr) =>
  fun (fromContract : ByStr) =>
  fun (toChainId : Uint64) =>
  fun (toContract : ByStr) =>
  fun (method : ByStr) =>
  fun (args : ByStr) =>
    (* tail: data *)
    let t1 = abi_encode_bytes txHash in
    let t2 = abi_encode_bytes crossChainId in
    let t3 = abi_encode_bytes fromContract in
    let t4 = builtin to_bystr empty_abi_encoded_string in
    let t5 = abi_encode_bytes toContract in
    let t6 = abi_encode_bytes method in
    (* compute offsets *)
    let o1 = u0xe0 in (* initial offset of 7 x 32 = 224 bytes used for headers *)
    let o2 = next_offset o1 t1 in
    let o3 = next_offset o2 t2 in
    let o4 = next_offset o3 t3 in
    let o5 = next_offset o4 t4 in
    let o6 = next_offset o5 t5 in
    let o7 = next_offset o6 t6 in
    (* head: offsets *)
    let h1 = abi_encode_length o1 in
    let h2 = append_abi_encoded_length h1 o2 in
    let h3 = append_abi_encoded_length h2 o3 in
    let h4 = append_abi_encoded_length h3 o4 in (* uint64 is a fixed type *)
    let h5 = append_abi_encoded_length h4 o5 in
    let h6 = append_abi_encoded_length h5 o6 in
    append_abi_encoded_length h6 o7
    (* TODO: incomplete. may not be needed *)

let decode_tx_param : ByStr -> TxParam =
  fun (rawParam : ByStr) =>
    (*
      uint offset = 0x20;
      (param.txHash,offset) = rlpGetNextBytes(rawParam, offset);
      (param.crossChainId,offset) = rlpGetNextBytes(rawParam, offset);
      (param.fromContract,offset) = rlpGetNextBytes(rawParam, offset);
      (param.toChainId,offset) = rlpGetNextUint64(rawParam, offset);
      (param.toContract,offset) = rlpGetNextBytes(rawParam, offset);
      (param.method,offset) = rlpGetNextBytes(rawParam, offset);
      (param.args,offset) = rlpGetNextBytes(rawParam, offset);
    *)
    let p1 = rlp_get_next_bytes rawParam u0x20 in match p1 with
    | Pair tx_hash o1 =>
    let p2 = rlp_get_next_bytes rawParam o1 in match p2 with
    | Pair cross_chain_id o2 =>
    let p3 = rlp_get_next_bytes rawParam o2 in match p3 with
    | Pair from_contract o3 =>
    let p4 = rlp_get_next_uint64 rawParam o3 in match p4 with
    | Pair to_chain_id o4 =>
    let p5 = rlp_get_next_bytes rawParam o4 in match p5 with
    | Pair to_contract o5 =>
    let p6 = rlp_get_next_bytes rawParam o5 in match p6 with
    | Pair method o6 =>
    let p7 = rlp_get_next_bytes rawParam o6 in match p7 with
    | Pair args _ =>
    TxParam tx_hash cross_chain_id from_contract to_chain_id to_contract method args
    end end end end end end end


let decode_cross_tx : ByStr -> CrossTx =
  fun (rawTx : ByStr) =>
    (*
      uint offset = 0x20;
      (,offset) = rlpReadKind(rawTx, offset);
      bytes memory crossTxParam;
      (crossTx.txHash,offset) = rlpGetNextBytes(rawTx, offset);
      (crossTx.fromChainID,offset) = rlpGetNextUint64(rawTx, offset);
      (crossTxParam,offset) = rlpGetNextBytes(rawTx, offset);
      crossTx.crossTxParam = decodeTxParam(crossTxParam);
    *)
    let p1 = rlp_read_kind rawTx u0x20 in
    let o1 = get_offset p1 in
    let p2 = rlp_get_next_bytes rawTx o1 in match p2 with
    | Pair tx_hash o2 =>
    let p3 = rlp_get_next_uint64 rawTx o2 in match p3 with
    | Pair from_chain_id o3 =>
    let p4 = rlp_get_next_bytes rawTx o3 in match p4 with
    | Pair tx_param_bz _ =>
    let tx_param = decode_tx_param tx_param_bz in
    CrossTx tx_hash from_chain_id tx_param
    end end end

(*
    /*
    Account Proof
     -key : keccak256(address[:])
     -val : rlp(state-obj)
     -root : header.Root

    Storage Proof
     -key : keccak256(slot-index) // 32bytes index
     -val : 32 bytes data
     -root : Account.storageHash

    rlp(state-obj) == rlp(Account)
     type Account struct {
	  Nonce    uint64
	  Balance  *big.Int
	  Root     bytes32   // also : storageHash
	  CodeHash []byte
    }
    */
    function verifyAccountProof(
        bytes memory _accountProof,
        bytes memory _headerRoot,
        bytes memory _address,
        bytes memory _storageProof,
        bytes memory _storageIndex
    ) internal pure returns(bytes memory value) {
         // verify account proof
        bytes memory _accountKey = _address;
        assembly {
            mstore(add(_accountKey,0x20), keccak256(add(_accountKey, 0x20), mload(_accountKey)))
            mstore(_accountKey, 0x20)
        }
        bytes memory account = verifyProof(_accountProof, _accountKey, _headerRoot);

        // decode state object
        (account,) = rlpSplit(account,0x20);
        (,uint offset) = rlpSplit(account,0x20); // nonce
        (,offset) = rlpSplit(account,offset);    // balance
        (bytes memory storageRoot,) = rlpSplit(account,offset);

        // verify storage proof
        bytes memory _storageKey = _storageIndex;
        assembly {
            mstore(add(_storageKey,0x20), keccak256(add(_storageKey, 0x20), mload(_storageKey)))
            mstore(_storageKey, 0x20)
        }
        value = verifyProof(_storageProof, _storageKey, storageRoot);
        (value,) = rlpSplit(value, 0x20);
    }

    // no copy , parse proof in-place , so if _proof is needed after , back up it.
    // for proof like: rlp([rlp(node1),rlp(node2),...,rlp(nodeN)])
    function verifyProof(bytes memory _proof, bytes memory _key, bytes memory _root) internal pure returns(bytes memory value) {
        _key = bytesToHex(_key);
        (_proof,) = rlpSplit(_proof,0x20); // get *[rlp(node1),rlp(node2),...,rlp(nodeN)]*
        uint offset = 0x20;
        uint size = _proof.length;
        value = _root; // *value* = *_root* ( which equal *hash(rlp(node1))* )

        for (;offset<size+0x20;) {
            bytes memory node; // memory for *nodeI*
            require(checkNodeHash(_proof,offset,value),"proof:unequal node hash"); // compare *nodeI-1.value* and *hash(rlp(nodeI))*
            (node,offset) = rlpSplit(_proof,offset); // get *nodeI*; _proof now: *[rlp(nodeI+1),rlp(nodeI+2),...,rlp(nodeN)]*

            (uint size_tmp,uint offset_tmp) = rlpReadKind(node,0x20);
            (size_tmp,offset_tmp) = rlpReadKind(node,offset_tmp+size_tmp);
            offset_tmp += size_tmp; // length of first two node elements
            if (offset_tmp==node.length+0x20) { // shortNode = [rlp(key),rlp(value)]
                (bytes memory keyElement,uint _offset) = rlpSplit(node,0x20);
                bool isIn;
                bytes memory subKey = compactToHex(keyElement);
                (_key,isIn) = compareKey(_key, subKey);
                require(isIn,"proof:invalid key");
                (value,) = rlpSplit(node,_offset);
            } else { // fullNode = [hash(child[0]),hash(child[1]),...,hash(child[15]),emptyKeyValue]
                uint index;
                if (_key.length==0) {
                    index = 17;
                } else {
                    (_key,index) = takeOneByte(_key);
                }
                uint _offset = 0x20;
                for (uint i=0;i<17;i++) {
                    if (index==i) {
                        (value,) = rlpSplit(node,_offset);
                        break;
                    } else {
                        (size_tmp,offset_tmp) = rlpReadKind(node,_offset);
                        _offset = offset_tmp + size_tmp;
                    }
                }
            }
        }

        require(_key.length==0,"proof:invalid key");
    }
*)

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract ZilCrossChainManagerV2(
  initial_owner: ByStr20,
  eccd: ByStr20 with contract
    field cur_epoch_validators : List ByStr20,
    field cur_epoch_start_height : Uint256,
    field cur_to_zion_index : Uint256,
    field from_chain_tx_exists : Map Uint64 (Map ByStr32 Bool)
  end
)

field contract_owner : Option ByStr20 = Some {ByStr20} initial_owner
field pending_owner : Option ByStr20 = none

(**************************************)
(*             Procedures             *)
(**************************************)

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsNotEmptyVals(vals : List ByStr20)
  is_empty = let l = address_list_length vals in builtin eq l u0x00;
  match is_empty with
  | False => (* ok *)
  | True =>
    err = CodeNoValidatorsInHeader;
    ThrowError err
  end
end

procedure ExecuteCrossChainTx(
  toContract : ByStr,
  method : ByStr,
  args : ByStr,
  fromContractAddr : ByStr,
  fromChainId : Uint64
)
  (* TODO: ensure to_contract is not proxy or data or this contract *)
  r = builtin to_bystr20 toContract;
  match r with
  | None =>
    err = CodeInvalidToContract;
    ThrowError err
  | Some recipient =>
    tag = builtin to_string method;
    msg_to_recipient =  {
      _tag : tag; _recipient: recipient; _amount: zero_amt;
      args: args; fromContractAddr: fromContractAddr; fromChainId: fromChainId
    };
    msgs = one_msg msg_to_recipient;
    send msgs
  end
end

(**************************************)
(*        Ownership Procedures        *)
(**************************************)

procedure IsOwner(address: ByStr20)
  maybe_current_owner <- contract_owner;
  match maybe_current_owner with
  | Some current_owner =>
    is_owner = builtin eq current_owner address;
    match is_owner with
    | True =>
    | False =>
      err = CodeNotOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotOwner;
    ThrowError err
  end
end

procedure IsPendingOwner(address: ByStr20)
  maybe_pending_owner <- pending_owner;
  match maybe_pending_owner with
  | Some current_pending_owner =>
    is_pending_owner = builtin eq current_pending_owner address;
    match is_pending_owner with
    | True =>
    | False =>
      err = CodeNotPendingOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotPendingOwner;
    ThrowError err
  end
end

(***************************************)
(*             Transitions             *)
(***************************************)

transition InitGenesisBlock(
  rawHeader : ByStr
)
  header = decode_header rawHeader;

  (* verify isInit *)
  cur_vals <- & eccd.cur_epoch_validators;
  was_empty = let l = address_list_length cur_vals in builtin eq l u0x00;
  match was_empty with
  | True => (* ok *)
  | False =>
    err = CodeAlreadyInitialized;
    ThrowError err
  end;

  (* get validators *)
  vals = get_validators_from_header rawHeader;
  IsNotEmptyVals vals;

  (* put epoch information *)
  number = get_number header;
  start_height = builtin add one number;
  msg_to_eccd =  {
    _tag : "PutEpochInfo"; _recipient: eccd; _amount: zero_amt;
    epoch_start_height: start_height; epoch_validators: vals
  };
  msgs = one_msg msg_to_eccd;
  send msgs;

  e = {
    _eventname: "GenesisBlockInitialized";
    number: number; rawHeader: rawHeader
  };
  event e
end

transition ChangeEpoch(
  rawHeader : ByStr,
  rawSeals : ByStr
)
  header = decode_header rawHeader;
  number = get_number header;

  (* verify block.height *)
  cur_epoch_start_height <- & eccd.cur_epoch_start_height;
  is_lower = builtin lt number cur_epoch_start_height;
  match is_lower with
  | False => (* ok*)
  | True =>
    err = CodeInvalidBlockHeight;
    ThrowError err
  end;

  (* verify header *)
  new_vals = get_validators_from_header rawHeader;
  IsNotEmptyVals new_vals;
  prev_vals <- & eccd.cur_epoch_validators;
  hash = builtin keccak256hash rawHeader;
  ok = verify_header hash rawSeals prev_vals;
  match ok with
  | True => (* ok *)
  | False =>
    err = CodeHeaderVerificationFailed;
    ThrowError err
  end;

  (* put new epoch information *)
  start_height = builtin add one number;
  msg_to_eccd =  {
    _tag : "PutEpochInfo"; _recipient: eccd; _amount: zero_amt;
    epoch_start_height: start_height; epoch_validators: new_vals
  };
  msgs = one_msg msg_to_eccd;
  send msgs;

  e = {
    _eventname: "EpochChanged";
    number: number; rawHeader: rawHeader; previousValidators: prev_vals; newValidators: new_vals
  };
  event e
end

transition CrossChain(
  toChainId : Uint64,
  toContract : ByStr,
  method : ByStr,
  txData : ByStr
)
  (*
    require(CallerFactory(EthCrossChainCallerFactoryAddress).isChild(msg.sender), "The caller is child of the caller factory!");
    uint256 txHashIndex = IEthCrossChainData(EthCrossChainDataAddress).getEthTxHashIndex();
    bytes memory paramTxHash = ECCUtils.uint256ToBytes(txHashIndex);
    bytes memory crossChainId = abi.encodePacked(sha256(abi.encodePacked(address(this), paramTxHash)));
  *)
  idx <- & eccd.cur_to_zion_index;
  idx_bz = let b = builtin to_bystr32 idx in builtin to_bystr b;
  id_bz = let a = builtin to_bystr _this_address in builtin concat a idx_bz;
  cross_chain_id = let hash = builtin keccak256hash id_bz in builtin to_bystr hash;
  sender = builtin to_bystr _sender;
  params = TxParam idx_bz cross_chain_id sender toChainId toContract method txData;
  tx_hash = builtin keccak256hash params;

  msg_to_eccd =  {
    _tag : "PutTxHash"; _recipient: eccd; _amount: zero_amt;
    tx_hash: tx_hash
  };
  msgs = one_msg msg_to_eccd;
  send msgs;

  (* retaining v1 event format *)
  e = {
    _eventname : "CrossChainEvent";
    sender : _origin;
    txId : idx_bz;
    proxyOrAssetContract : _sender;
    toChainId : toChainId;
    toContract : toContract;
    rawdata : params
  };
  event e
end

transition VerifyHeaderAndExecuteTx(
  rawHeader : ByStr,
  rawSeals : ByStr,
  accountProof : ByStr,
  storageProof : ByStr,
  rawCrossTx : ByStr
)
  header = decode_header rawHeader;
  cross_tx = decode_cross_tx rawCrossTx;
  number = get_number header;

  (* verify block.height *)
  cur_epoch_start_height <- & eccd.cur_epoch_start_height;
  is_lower = builtin lt number cur_epoch_start_height;
  match is_lower with
  | False => (* ok*)
  | True =>
    err = CodeInvalidBlockHeight;
    ThrowError err
  end;

  (* verify header *)
  prev_vals <- & eccd.cur_epoch_validators;
  hash = builtin keccak256hash rawHeader;
  ok = verify_header hash rawSeals prev_vals;
  match ok with
  | True => (* ok *)
  | False =>
    err = CodeHeaderVerificationFailed;
    ThrowError err
  end;

  (* TODO: verify proof *)
  (*
    bytes memory storageIndex = ECCUtils.getCrossTxStorageSlot(crossTx);
    bytes memory storageValue = ECCUtils.verifyAccountProof(accountProof, header.root, ZionCrossChainManagerAddress, storageProof, storageIndex);
    require(ECCUtils.bytesToBytes32(storageValue) == keccak256(rawCrossTx), "Verify proof failed");
  *)

  match cross_tx with
  | CrossTx tx_hash from_chain_id tx_param =>
    (* check & put tx exection information *)
    t = builtin to_bystr32 tx_hash;
    match t with
    | Some tx_hash_fixed =>
      e <- & eccd.from_chain_tx_exists[from_chain_id][tx_hash_fixed];
      match e with
      | None => (* ok *)
      | Some _ =>
        err = CodeTxAlreadyExecuted;
        ThrowError err
      end
    | None =>
      err = CodeInvalidTxHash;
      ThrowError err
    end;

    match tx_param with
    | TxParam from_tx_hash cross_chain_id from_contract to_chain_id to_contract method args =>
      is_right_chain = builtin eq zilliqa_chain_id to_chain_id;
      match is_right_chain with
      | True => (* ok *)
      | False =>
        err = CodeInvalidToChainID;
        ThrowError err
      end;

      from_tx_hash_fixed = builtin to_bystr32 from_tx_hash;

      msg_to_eccd =  {
        _tag : "MarkTxExecuted"; _recipient: eccd; _amount: zero_amt;
        from_chain_id: from_chain_id; from_tx_hash: from_tx_hash_fixed
      };
      msgs = one_msg msg_to_eccd;
      send msgs;

      ExecuteCrossChainTx to_contract method args from_contract from_chain_id;

      (* retain v1 events *)
      e = {
        _eventname: "VerifyHeaderAndExecuteTxEvent";
        fromChainId : from_chain_id;
        toContractAddr : to_contract;
        crossChainTxHash : tx_hash;
        fromChainTxHash : from_tx_hash
      };
      event e
    end
  end
end

(***************************************************)
(*              Ownership Transitions              *)
(***************************************************)

(* @dev: Transfers contract ownership to a new address. The new address must call the AcceptOwnership transition to finalize the transfer. *)
(* @param new_owner: Address of the new contract_owner.                                                                                    *)
transition TransferOwnership(new_owner: ByStr20)
  IsOwner _sender;
  o = Some {ByStr20} new_owner;
  pending_owner := o;
  e = {_eventname : "OwnershipTransferInitiated"; contract_owner : _sender; pending_owner : new_owner};
  event e
end

(* @dev: Finalizes transfer of contract ownership. Must be called by the new contract_owner. *)
transition AcceptOwnership()
  IsPendingOwner _sender;
  previous_contract_owner <- contract_owner;
  o = Some {ByStr20} _sender;
  contract_owner := o;
  pending_owner := none;
  e = {_eventname : "OwnershipTransferAccepted"; previous_contract_owner : previous_contract_owner; contract_owner : _sender};
  event e
end
