scilla_version 0

import Conversions PairUtils ListUtils NatUtils BoolUtils

(* See: https://github.com/polynetwork/eth-contracts/blob/2.0/contracts/core/cross_chain_manager/logic/EthCrossChainManagerImplementation.sol *)

(***************************************************)
(*               Associated library                *)
(***************************************************)

library ZilCrossChainManagerV2

let true = True
let false = False
let zero_amt = Uint128 0
let zero_string = "0"
let ten_string = "10"
let one = Uint256 1
let none = None {ByStr20}
let big_endian = BigEndian
let padding = let x = 0x00 in builtin to_bystr x
let ten_padding = let x = 0x10 in builtin to_bystr x
let nil_address = 0x0000000000000000000000000000000000000000
let one_address = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
let empty_abi_encoded_string = 0x000000000000000000000000000000000000000000000000000000000000000000000000
let zion_ccm_address = 0x0000000000000000000000000000000000001003
let address_list_length = @list_length ByStr20

let zilliqa_chain_id = Uint64 333
let zion_seal_length = Uint32 67     (* rlpPrefix: 2 , r: 32 , s:32 , v:1 *)
let zion_peer_length = Uint32 93     (* rlpPrefix: 2 , pk_rlp: 70 , address_rlp: 21 *)
let zion_address_length = Uint32 21  (* rlpPrefix: 1 , address: 20 *)

(* byte constants *)
let u0x00 = Uint32 0
let u0x01 = Uint32 1
let u0x02 = Uint32 2
let u0x03 = Uint32 3
let u0x04 = Uint32 4
let u0x05 = Uint32 5
let u0x08 = Uint32 8
let u0x0a = Uint32 10
let u0x0c = Uint32 12
let u0x10 = Uint32 16
let u0x11 = Uint32 17
let u0x14 = Uint32 20
let u0x15 = Uint32 21
let u0x16 = Uint32 22
let u0x17 = Uint32 23
let u0x1f = Uint32 31
let u0x20 = Uint32 32
let u0x40 = Uint32 64
let u0x7e = Uint32 126
let u0x80 = Uint32 128
let u0xb6 = Uint32 182
let u0xb7 = Uint32 183
let u0xb8 = Uint32 184
let u0xba = Uint32 186
let u0xbe = Uint32 190
let u0xc0 = Uint32 192
let u0xd5 = Uint32 213
let u0xd6 = Uint32 214
let u0xd7 = Uint32 215
let u0xe0 = Uint32 224
let u0xf6 = Uint32 246
let u0xf7 = Uint32 247
let u0xf8 = Uint32 248
let u0xf9 = Uint32 249
let u0x117 = Uint32 279
let u0x115 = Uint32 277

(* Error events *)
type Error =
  | CodeNotOwner
  | CodeNotPendingOwner
  | CodeAlreadyInitialized
  | CodeNoValidatorsInHeader
  | CodeHeaderVerificationFailed
  | CodeInvalidBlockHeight
  | CodeInvalidTxHash
  | CodeInvalidToChainID
  | CodeInvalidToContract
  | CodeTxAlreadyExecuted
  | CodeVerifyProofFailed
  | CodeUnequalNodeHash
  | CodeCompareKeyFailed
  | CodeKeyLengthNotZero
  | CodeProxyValidationFailed

let make_error =
  fun (result : Error) =>
    let result_code =
      match result with
      | CodeNotOwner                  => Int32 -1
      | CodeNotPendingOwner           => Int32 -2
      | CodeAlreadyInitialized        => Int32 -3
      | CodeNoValidatorsInHeader      => Int32 -4
      | CodeHeaderVerificationFailed  => Int32 -5
      | CodeInvalidBlockHeight        => Int32 -6
      | CodeInvalidTxHash             => Int32 -7
      | CodeInvalidToChainID          => Int32 -8
      | CodeInvalidToContract         => Int32 -9
      | CodeTxAlreadyExecuted         => Int32 -10
      | CodeVerifyProofFailed         => Int32 -11
      | CodeUnequalNodeHash           => Int32 -12
      | CodeCompareKeyFailed          => Int32 -13
      | CodeKeyLengthNotZero          => Int32 -14
      | CodeProxyValidationFailed     => Int32 -15
      end
    in
    { _exception : "Error"; code : result_code }

let one_msg =
  fun (msg : Message) =>
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

(* Zion header parsing *)

type Header =
  | Header of ByStr Uint256 (* root, number *)

let get_number : Header -> Uint256 =
  fun (h : Header) =>
  match h with
  | Header root number =>
    number
  end

let get_root : Header -> ByStr =
  fun (h : Header) =>
  match h with
  | Header root number =>
    root
  end

(* Cross chain tx params *)
type TxParam =
  | TxParam of
    ByStr  (* source chain txHash *)
    ByStr  (* crossChainId *)
    ByStr  (* fromContract *)
    Uint64 (* toChainId *)
    ByStr  (* toContract *)
    ByStr  (* method *)
    ByStr  (* args *)


type CrossTx =
  | CrossTx of
    ByStr   (* zion txHash *)
    Uint64  (* fromChainId *)
    TxParam (* cross chain tx param *)

type KeyOffsetValue = 
  | KeyOffsetValue of ByStr Uint32 ByStr (* key, offset, value *)
  
let get_number : Header -> Uint256 =
  fun (h : Header) =>
    match h with
    | Header root number =>
      number
    end
  
(* extracts the key from KeyOffsetValue ADT *)
let get_key : KeyOffsetValue -> ByStr =
  fun (kov : KeyOffsetValue) =>
    match kov with
    | KeyOffsetValue key offset value =>
      key
    end
  
(* extracts the offset from KeyOffsetValue ADT *)
let get_key_offset : KeyOffsetValue -> Uint32 =
  fun (kov : KeyOffsetValue) =>
    match kov with
    | KeyOffsetValue key offset value =>
      offset
    end
  
(* extracts the value from KeyOffsetValue ADT *) 
let get_value : KeyOffsetValue -> ByStr =
  fun (kov : KeyOffsetValue) =>
    match kov with
    | KeyOffsetValue key offset value =>
      value
    end
  
(* extracts the keySlice from Pair (keySlice, isIn) *)
let get_key_slice : Pair ByStr Bool -> ByStr = @fst ByStr Bool
  
(* extracts the isIn from Pair (keySlice, isIn) *)
let get_is_in : Pair ByStr Bool -> Bool = @snd ByStr Bool
  
(* extracts the buffer from Pair (buffer, index) *)
let get_buffer : Pair ByStr Uint32 -> ByStr = @fst ByStr Uint32
  
(* extracts the index from Pair (buffer, index) *)
let get_index : Pair ByStr Uint32 -> Uint32 = @snd ByStr Uint32
  
(* extracts the final value from verify_proof Pair (value, isSuccessful) *)
let get_verify_proof_value : Pair ByStr Bool -> ByStr = @fst ByStr Bool
  
(* extracts the boolean from verify_proof Pair (value, isSuccessful) *)
let get_verify_proof_success : Pair ByStr Bool -> Bool = @snd ByStr Bool

(* converts a Uint32 to a Uint256 *)
let grow : Uint32 -> Uint256 =
  fun (var : Uint32) =>
    let maybe_big = builtin to_uint256 var in
    match maybe_big with
    | Some big => big
    | None => Uint256 0 (* should never happen: u32->u256 *)
    end

(* converts a Uint64 to a Uint256 *)
let grow_u64 : Uint64 -> Uint256 =
  fun (var : Uint64) =>
    let maybe_big = builtin to_uint256 var in
    match maybe_big with
    | Some big => big
    | None => Uint256 0 (* should never happen: u364>u256 *)
    end

(* extracts the address from Pair (address, offset) *)
let get_address : Pair ByStr20 Uint32 -> ByStr20 = @fst ByStr20 Uint32

(* extracts the data from Pair (data, offset) *)
let get_data : Pair ByStr Uint32 -> ByStr = @fst ByStr Uint32

(* extracts the offset from Pair (data, offset) *)
let get_split_offset : Pair ByStr Uint32 -> Uint32 = @snd ByStr Uint32

(* extracts the size from Pair (size, offset) *)
let get_size : Pair Uint32 Uint32 -> Uint32 = @fst Uint32 Uint32

(* extracts the offset from Pair (size, offset) *)
let get_offset : Pair Uint32 Uint32 -> Uint32 = @snd Uint32 Uint32

(* extracts the offset from Pair (data_u64, offset_u32) *)
let get_offset_u64 : Pair Uint64 Uint32 -> Uint32 = @snd Uint64 Uint32

(* extracts the data from Pair (data_u64, offset_u32) *)
let get_data_u64 : Pair Uint64 Uint32 -> Uint64 = @fst Uint64 Uint32

(* extracts the size + offset from Pair (size, offset) *)
let get_data_offset : Pair Uint32 Uint32 -> Uint32 =
  fun (pair : Pair Uint32 Uint32) =>
    match pair with
    | Pair size offset => builtin add size offset
    end

(* left pads a byte string with 0s *)
let pad : ByStr -> Uint32 -> ByStr =
  fun (buffer : ByStr) =>
  fun (required_length : Uint32) =>
    let current_length = builtin strlen buffer in
    let padding_length = builtin sub required_length current_length in
    let fold = @nat_fold ByStr in
    let fn = fun (cur : ByStr) => fun (num : Nat) => builtin concat padding cur in
    let count = builtin to_nat padding_length in
    fold fn buffer count

(* right pads a byte string with 0s *)
let right_pad : ByStr -> Uint32 -> ByStr =
  fun (buffer : ByStr) =>
  fun (required_length : Uint32) =>
    let current_length = builtin strlen buffer in
    let padding_length = builtin sub required_length current_length in
    let fold = @nat_fold ByStr in
    let fn = fun (cur : ByStr) => fun (num : Nat) => builtin concat cur padding in
    let count = builtin to_nat padding_length in
    fold fn buffer count

(* right pad bytes with 0s such that it is a multiple of 32 bytes (u255) *)
let pad_bytes: ByStr -> ByStr =
  fun (bz : ByStr) =>
    let data_length = builtin strlen bz in
    let padding_length = builtin rem data_length u0x20 in
    let padding_not_required = builtin eq padding_length u0x00 in
    match padding_not_required with
    | True => bz
    | False =>
      let padding_required = builtin sub u0x20 padding_length in
      let fold = @nat_fold ByStr in
      let fn = fun (cur : ByStr) => fun (num : Nat) => builtin concat cur padding in
      let count = builtin to_nat padding_required in
      fold fn bz count
    end

let rlp_read_kind: ByStr -> Uint32 -> Pair Uint32 Uint32 =
  fun (raw : ByStr) =>
  fun (offset : Uint32) =>
    (*
      assembly {
          k := shr(0xf8,mload(add(raw,offset)))
          // shift word at position offset in raw by 0xf8 (248 bits)
          // => i.e. remove last 248 bits and read the first 256-248 = 8 bits = 1 byte
      }
    *)
    let res = extract_bystr1 raw offset in
    match res with
    | None =>
      (* ERR! just blow up here *)
      let exception_code = Uint32 1001 in (* make this err easy to find *)
      let size = builtin sub u0x00 exception_code in
      Pair {Uint32 Uint32} size offset
    | Some pair =>
      match pair with
      | Pair k_bystr _ =>
        let k = builtin to_uint32 k_bystr in
        let lt_0x80 = builtin lt k u0x80 in
        let lt_0xb7 = builtin lt k u0xb7 in
        let lt_0xc0 = builtin lt k u0xc0 in
        let lt_0xf7 = builtin lt k u0xf7 in
        match lt_0x80 with | True =>
        (*
          if (k<0x80) {
              assembly {
                  size := 1
                  offset_ := offset
              }
              return (size,offset_);
          }
        *)
          let size = u0x01 in
          Pair {Uint32 Uint32} size offset | False =>
        match lt_0xb7 with | True =>
          (*
            if (k<0xb7) {
                assembly {
                    size := sub(k,0x80)
                    offset_ := add(offset,1)
                }
                return (size,offset_);
            }
          *)
          let size = builtin sub k u0x80 in
          let next_offset = builtin add offset u0x01 in
          Pair {Uint32 Uint32} size next_offset | False =>
        match lt_0xc0 with | True =>
          (*
            if (k<0xc0) {
                assembly {
                    size := shr(mul(8,sub(0xd7,k)),mload(add(add(raw,offset),0x01)))
                    // the value is at raw + offset + 1. note shr is in bits but mload is in bytes
                    // shift is 8*(0xd7 - k) => this determines how many bytes to read in for the size
                    // => this can be from 23 to 32 bytes
                    // so we just need to cut the raw bystr from (offset + 1) to (0xd7 - k) and convert it to a uint32
                    offset_ := add(offset,sub(k,0xb6))
                    // next offset is offset + (k - 0xb6)
                }
                return (size,offset_);
            }
          *)
          let idx = builtin add offset u0x01 in
          let len = let temp = builtin sub u0xd7 k in builtin sub u0x20 temp in (* we don't have to multiply by 8 here, as len is in bytes *)
          let size_bz = builtin substr raw idx len in
          let size_bz_padded = pad size_bz u0x04 in
          let maybe_size_bz_4 = builtin to_bystr4 size_bz_padded in (* must be 32 bytes long for proper extraction *)
          match maybe_size_bz_4 with
          | None =>
            (* ERR! just blow up here *)
            let exception_code = Uint32 1002 in (* make this err easy to find *)
            let s = builtin sub u0x00 exception_code in
            Pair {Uint32 Uint32} s offset
          | Some size_bz_4 =>
            let size = builtin to_uint32 size_bz_4 in
            let next_offset = let x = builtin sub k u0xb6 in builtin add x offset in
            Pair {Uint32 Uint32} size next_offset
          end
          | False =>
        match lt_0xf7 with | True =>
          (*
            if (k<0xf7) {
                assembly {
                    size := sub(k,0xc0)
                    offset_ := add(offset,1)
                }
                return (size,offset_);
            }
          *)
          let size = builtin sub k u0xc0 in
          let next_offset = builtin add offset u0x01 in
          Pair {Uint32 Uint32} size next_offset
        | False =>
          (*
            {
                assembly {
                    size := shr(mul(8,sub(0x117,k)),mload(add(add(raw,offset),0x01)))
                    // the value is at raw + offset + 1. note shr is in bits but mload is in bytes
                    // shift is 8*(0x117 - k) => this determines how many bytes to read in for the size
                    // => this can be from 14 to 31 bytes
                    // so we just need to cut the bystr from (offset + 1) to (0x117 - k) and convert it to a uint32
                    offset_ := add(offset,sub(k,0xf6))
                    // next offset is offset + (k - 0xf6)
                }
            }
          *)
          let idx = builtin add offset u0x01 in
          let len = let temp = builtin sub u0x117 k in builtin sub u0x20 temp in (* we don't have to multiply by 8 here, as len is in bytes *)
          let size_bz = builtin substr raw idx len in
          let size_bz_padded = pad size_bz u0x04 in
          let maybe_size_bz_4 = builtin to_bystr4 size_bz_padded in (* must be 32 bytes long for proper extraction *)
          match maybe_size_bz_4 with
          | None =>
            (* ERR! just blow up here *)
            let exception_code = Uint32 1003 in (* make this err easy to find *)
            let s = builtin sub u0x00 exception_code in
            Pair {Uint32 Uint32} s offset
          | Some size_bz_4 =>
            let size = builtin to_uint32 size_bz_4 in
            let next_offset = let x = builtin sub k u0xf6 in builtin add x offset in
            Pair {Uint32 Uint32} size next_offset
          end
        end
        end
        end
        end
      end
    end

(* NOTE: do NOT use `raw` with offset < returned offset as it has not been modified. *)
let rlp_split : ByStr -> Uint32 -> Pair ByStr Uint32 =
  fun (raw : ByStr) =>
  fun (offset : Uint32) =>
    (*
      uint size;
      (size,offset_) = rlpReadKind(raw,offset);
      // [offset_,...offset_+size]
      assembly {
          mstore(add(raw,sub(offset_,0x20)),size)
          // write size into the 32 bytes before the data
          // [offset_-32,...,offset_,...,offset_+size]
          res := add(raw,sub(offset_,0x20))
          // return next offset starting from the size
          // [res,...,offset_,...,offset_+size]
          offset_ := add(offset_,size)
          // replace offset_ to end
          // [res,...,o,...,offset_,...]
      }
    *)
    let p = rlp_read_kind raw offset in
    match p with
    | Pair size data_offset =>
      let res = builtin substr raw data_offset size in (* ignore `bytes` prefix and just return the data *)
      let next_offset = builtin add size data_offset in
      Pair {ByStr Uint32} res next_offset
    end

let rlp_get_next_bytes : ByStr -> Uint32 -> Pair ByStr Uint32 =
  fun (raw : ByStr) =>
  fun (offset : Uint32) =>
    (*
      uint size;
      (size,offset) = rlpReadKind(raw, offset);
      _offset = size + offset;
    *)
    let p = rlp_read_kind raw offset in
    match p with
    | Pair size data_offset =>
      let new_offset = builtin add size data_offset in
      (*
        assembly {
            res := mload(0x40)
            // load the nxt free memory addr
            let alloc := add(0x20, mul(0x20, div(add(size,0x1f), 0x20)))
            // required alloc is 32 + 32*((size+31)/32), i.e. (size in bytes rounded up to nearest word (32 bytes / 256 bits) + 1) word
            mstore(0x40, add(res,alloc))
            // move the nxt free memory addr by alloc bits
            mstore(res,size)
            // put 1 byte size at the start of buffer
            pop(staticcall(gas(),0x4,add(raw,offset), size, add(res,0x20), size))
            // call datacopy precompiled contract (0x4) contract with in=(raw+offset), insize=size, out=nxt free addr, outsize=size
            // so all this basically just puts [...size, sizebytes] into res
        }
      *)
      let data_bz = builtin substr raw data_offset size in
      (* let required_size = let x = builtin add size u0x1f in let y = builtin div x u0x20 in let z = builtin add y u0x01 in builtin mul z u0x20 in
      let data_bz_padded = pad data_bz required_size in *)
      Pair {ByStr Uint32} data_bz new_offset (* ignore the size prefix for `bytes` *)
    end

let rlp_get_next_uint256 : ByStr -> Uint32 -> Pair Uint256 Uint32 =
  fun (raw : ByStr) =>
  fun (offset : Uint32) =>
    (*
      uint size;
      (size,offset) = rlpReadKind(raw, offset);
      require(size<=32,"rlpGetNextUint256: data longer than 32 bytes");
      // this is auto-checked with builtin sub
      _offset = size + offset;
      assembly {
          let pad := sub(0x20,size)
          // padding is 32 - size
          res := shr(mul(pad,8), shl(mul(pad,8), mload(add(raw,sub(offset,pad)))))
          // load word at (offset - pad), meaning there is pad bytes worth of useless data on the left
          // then shift left then shift right by pad bytes, i.e. this zeroes out pad bytes on the left
      }
    *)
    let p = rlp_read_kind raw offset in
    match p with
    | Pair size data_offset =>
      (* we just read the required size and pad left to 0x20 *)
      let bz = builtin substr raw data_offset size in
      let bz_padded = pad bz u0x20 in
      let bz_fixed = builtin to_bystr32 bz_padded in
      match bz_fixed with
      | None =>
        (* just blow up, should never happen *)
        let exception_code = Uint256 1004 in (* make this err easy to find *)
        let z = Uint256 0 in
        let value = builtin sub z exception_code in
        Pair {Uint256 Uint32} value data_offset
      | Some b =>
        let value = builtin to_uint256 b in
        let next_offset = builtin add size data_offset in
        Pair {Uint256 Uint32} value next_offset
      end
    end

let rlp_get_next_uint64 : ByStr -> Uint32 -> Pair Uint64 Uint32 =
  fun (raw : ByStr) =>
  fun (offset : Uint32) =>
    (*
      // same as rlp_get_next_uint256 except size check
      uint size;
      (size,offset) = rlpReadKind(raw, offset);
      require(size<=8,"rlpGetNextUint64: data longer than 8 bytes");
      _offset = size + offset;
      assembly {
          let pad := sub(0x20,size)
          res := shr(mul(pad,8), shl(mul(pad,8), mload(add(raw,sub(offset,pad)))))
      }
    *)
    let r = rlp_get_next_uint256 raw offset in
    match r with
    | Pair i o =>
      let small = builtin to_uint64 i in
      match small with
      | None =>
        (* size check for require(size<=8,"rlpGetNextUint64: data longer than 8 bytes"); *)
        let exception_code = Uint64 1005 in (* make this err easy to find *)
        let z = Uint64 0 in
        let value = builtin sub z exception_code in
        Pair {Uint64 Uint32} value o
      | Some u64 =>
        Pair {Uint64 Uint32} u64 o
      end
    end

let rlp_get_next_address : ByStr -> Uint32 -> Pair ByStr20 Uint32 =
  fun (raw : ByStr) =>
  fun (offset : Uint32) =>
  (*
    uint size;
    (size,offset) = rlpReadKind(raw, offset);
    require(size<=0x14,"rlpGetNextAddress: data longer than 20 bytes");
    _offset = size + offset;
    assembly {
        let pad := sub(0x20,size)
        res := shr(mul(pad,8), shl(mul(pad,8), mload(add(raw,sub(offset,pad)))))
        // load size bytes into a 32 byte buffer, padding the left bytes with zeroes
        // (see: same as in rlp_get_next_uint256 above)
    }
  *)
  let p = rlp_read_kind raw offset in
  match p with
  | Pair size data_offset =>
    let check = builtin sub u0x14 size in
    let bz = builtin substr raw data_offset u0x14 in
    (* let bz_padded = pad bz u0x14 in *)
    let m = builtin to_bystr20 bz in
    match m with
    | None =>
        (* ERR! just blow up here *)
        let exception_code = Uint32 1006 in (* make this err easy to find *)
        let next_offset = builtin sub u0x00 exception_code in
        Pair {ByStr20 Uint32} nil_address next_offset
    | Some bz_fixed =>
      let next_offset = builtin add size offset in
      Pair {ByStr20 Uint32} bz_fixed next_offset
    end
  end

let decode_header : ByStr -> Header =
  fun (rawHeader : ByStr) =>
  (*
    (,uint offset) = rlpReadKind(rawHeader,0x20);
    (header.root,) = rlpGetNextBytes(rawHeader, offset + 87); // position of Root
    (size,offset) = rlpReadKind(rawHeader, offset + 445); // position of Difficulty
    (header.number,) = rlpGetNextUint256(rawHeader, offset + size);  // position of Number
  *)
    let p1 = rlp_read_kind rawHeader u0x00 in (* ignore `bytes` prefix *)
    let offset = get_offset p1 in
    let o2 = let x = Uint32 87 in builtin add offset x in
    let p2 = rlp_get_next_bytes rawHeader o2 in
    match p2 with
    | Pair root _ =>
      let o3 = let x = Uint32 445 in builtin add offset x in
      let p3 = rlp_read_kind rawHeader o3 in
      match p3 with
      | Pair size offset2 =>
        let o4 = builtin add offset2 size in
        let p4 = rlp_get_next_uint256 rawHeader o4 in
        match p4 with
        | Pair number _ =>
          Header root number
        end
      end
    end

let get_header_validators_and_epoch_end_height : ByStr -> Pair Uint256 (List ByStr20) =
  fun (rawHeader : ByStr) =>
  (*
    (,uint offset) = rlpReadKind(rawHeader,0x20);
    (size,offset) = rlpReadKind(rawHeader, offset + 445 ); // position of Difficulty
    (size,offset) = rlpReadKind(rawHeader, offset + size); // position of Number
    (size,offset) = rlpReadKind(rawHeader, offset + size); // position of GasLimit
    (size,offset) = rlpReadKind(rawHeader, offset + size); // position of GasUsed
    (size,offset) = rlpReadKind(rawHeader, offset + size); // position of Time
    (,offset) = rlpReadKind(rawHeader, offset + size); // position of Extra(with digest)
    (,offset) = rlpReadKind(rawHeader, offset + 0x20); // position of Extra(without digest) , a bytes32 digest is appended before extra
    (size,offset) = rlpReadKind(rawHeader, offset);        // position of Extra.EpochStartHeight
    (endHeight,offset) = rlpGetNextUint64(rawHeader, offset + size); // position of Extra.EpochEndHeight
    (bytes memory validatorsBytes,) = rlpGetNextBytes(rawHeader, offset);
    size = validatorsBytes.length;
    require(size%ZION_ADDRESS_LEN==0,"invalid header extra validatorSet");
    validators = new address[](size/ZION_ADDRESS_LEN);
    for (uint i = 0; i*ZION_ADDRESS_LEN<size; i++) {
        (address valAddr,) = rlpGetNextAddress(validatorsBytes, 0x20 + i*ZION_ADDRESS_LEN);
        validators[i] = valAddr;
    }
  *)
  let p1 = rlp_read_kind rawHeader u0x00 in (* ignore `bytes` prefix *)
  let p2 = let o1 = get_offset p1 in
           let u445 = Uint32 445 in
           let o = builtin add u445 o1 in rlp_read_kind rawHeader o in (* position of Difficulty *)
  let p3 = let o = get_data_offset p2 in rlp_read_kind rawHeader o in (* position of Number *)
  let p4 = let o = get_data_offset p3 in rlp_read_kind rawHeader o in (* position of GasLimit *)
  let p5 = let o = get_data_offset p4 in rlp_read_kind rawHeader o in (* position of GasUsed *)
  let p6 = let o = get_data_offset p5 in rlp_read_kind rawHeader o in (* position of Time *)
  let p7 = let o = get_data_offset p6 in rlp_read_kind rawHeader o in (* position of Extra(with digest) *)
  let p8 = let o1 = get_offset p7 in let o = builtin add o1 u0x20 in rlp_read_kind rawHeader o in (* position of Extra(without digest) , a bytes32 digest is appended before extra *)
  let p9 = let o = get_offset p8 in rlp_read_kind rawHeader o in (* position of Extra.EpochStartHeight *)
  let p10 = let o = get_data_offset p9 in rlp_get_next_uint64 rawHeader o in (* position of Extra.EpochEndHeight *)
  let epoch_end_height_u64 = get_data_u64 p10 in
  let epoch_end_height_u256 = grow_u64 epoch_end_height_u64 in
  let val_bz = let o = get_offset_u64 p10 in let b = rlp_get_next_bytes rawHeader o in get_data b in
  let size = builtin strlen val_bz in
  let check = builtin rem size zion_address_length in
  let throw_if_not_zero = builtin sub u0x00 check in
  let length = builtin div size zion_address_length in
  let initial = Nil {ByStr20} in
  let count = builtin to_nat length in
  let fold = @nat_fold (List ByStr20) in
  let fn = fun (cur : List ByStr20) => fun (num : Nat) =>
    let i = nat_to_int num in
    let o = builtin mul i zion_address_length in
    let r = rlp_get_next_address val_bz o in
    let val = get_address r in
    Cons {ByStr20} val cur
  in
  (* array is constructed by pushing to the head of list - reverse to maintain right order *)
  let array = fold fn initial count in
  Pair {Uint256 (List ByStr20)} epoch_end_height_u256 array

let has_enough_signers : List ByStr20 -> List ByStr20 -> Bool =
  fun (validators : List ByStr20) =>
  fun (signers : List ByStr20) =>
    (*
        uint _m = _validators.length.mul(2).div(3).add(1);
        bool[] memory _checked = new bool[](_validators.length);
        uint m = 0;
        for(uint i = 0; i < _signers.length; i++){
            for (uint j = 0; j < _validators.length; j++) {
                if (!_checked[j] && _signers[i]==_validators[j]) {
                    m++;
                    _checked[j] = true;
                    break;
                }
            }
        }
        return m >= _m;
    *)
    let val_count = address_list_length validators in
    let required = let x = builtin mul val_count u0x02 in let y = builtin div x u0x03 in builtin add y u0x01 in
    let fold = @list_foldl ByStr20 Uint32 in
    let fold_fn = fun (acc : Uint32) => fun (validator : ByStr20) =>
      let finder = @list_exists ByStr20 in
      let equality_fn = fun (signer : ByStr20) => builtin eq signer validator in
      let found = finder equality_fn signers in
      match found with
      | True =>
        (* NOTE: here we assume that all validators are unique, which should be ok? *)
        (* if validators are not unique, have to filter signers list to prevent double counting *)
        builtin add acc u0x01
      | False => acc (* no change if not found *)
      end
    in
    let matched = fold fold_fn u0x00 validators in
    let insufficient = builtin lt required matched in
    match insufficient with
      | True => False
      | False => True
    end

let verify_seal : ByStr32 -> ByStr -> ByStr20 =
  fun (sigHash : ByStr32) =>
  fun (seal : ByStr) =>
    (*
      function verifySeal(bytes32 sigHash, bytes memory seal) internal pure returns(address signer) {
          if (seal.length != 65) {
              return (address(0));
          }

          bytes32 r;
          bytes32 s;
          uint8 v;

          assembly {
              r := mload(add(seal, 0x20))
              s := mload(add(seal, 0x40))
              v := add(27, byte(0, mload(add(seal, 0x60))))
          }

          // uncomment codes below if needed
          // if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
          //     return address(0);
          // }

          // if (v != 27 && v != 28) {
          //     return address(0);
          // }

          return ecrecover(sigHash, v, r, s);
      }
    *)
    let rs = builtin substr seal u0x00 u0x40 in
    let m1 = builtin to_bystr64 rs in
    match m1 with
    | None => nil_address (* shld never happen. nil addr === fail *)
    | Some sig =>
      let v = builtin substr seal u0x40 u0x01 in
      let m2 = builtin to_bystr1 v in
      match m2 with
      | None => nil_address (* shld never happen. nil addr === fail *)
      | Some v_fixed =>
        let data = builtin to_bystr sigHash in
        let recid = builtin to_uint32 v_fixed in
        let pk = builtin ecdsa_recover_pk data sig recid in
        let hash = builtin keccak256hash pk in
        let hash_bz = builtin to_bystr hash in
        let addr_bz = builtin substr hash_bz u0x0c u0x14 in (* address is last 20 bytes of pk hash, idx: 32 - 20 = 12 => u0x0c *)
        let a = builtin to_bystr20 addr_bz in
        match a with
        | None => nil_address (* shld never happen. nil addr === fail *)
        | Some addr => addr
        end
      end
    end

let verify_header : ByStr32 -> ByStr -> List ByStr20 -> Bool =
  fun (headerHash : ByStr32) =>
  fun (rawSeals : ByStr) =>
  fun (validators : List ByStr20) =>
    (*
      uint offset = 0x20;  // accounting for `bytes` prefix, not required for ByStr
      bytes memory seal;

      (rawSeals,) = rlpSplit(rawSeals, 0x20);
      uint sealCount = rawSeals.length.div(ZION_SEAL_LEN);
      address[] memory signers = new address[](sealCount);

      for (uint i=0; i<sealCount; i++) {
          (seal,offset) = rlpSplit(rawSeals, offset);
          signers[i] = verifySeal(keccak256(abi.encodePacked(headerHash)), seal);
          if (signers[i] == address(0)) {
              return false;
          }
      }
      return hasEnoughSigners(validators, signers);
    *)
    let p = rlp_split rawSeals u0x00 in (* ignore `bytes` prefix *)
    let raw_seals_data = get_data p in
    let raw_seals_len = builtin strlen raw_seals_data in
    let seal_count = builtin div raw_seals_len zion_seal_length in
    let count = builtin to_nat seal_count in
    let signers = Nil {ByStr20} in
    let acc = Pair {(List ByStr20) Uint32} signers u0x00 in (* ignore `bytes` prefix; initial offset is 0 instead of 32 *)
    let fold = @nat_fold (Pair (List ByStr20) Uint32) in
    let fn = fun (cur : Pair (List ByStr20) Uint32) => fun (num : Nat) =>
      match cur with
      | Pair signers offset =>
        let p1 = rlp_split raw_seals_data offset in
        match p1 with
        | Pair seal new_offset =>
          let hash = builtin keccak256hash headerHash in
          let signer = verify_seal hash seal in
          let new_list = Cons {ByStr20} signer signers in
          Pair {(List ByStr20) Uint32} new_list new_offset
        end
      end
    in
    let res = fold fn acc count in
    match res with
    | Pair list _ =>
      has_enough_signers validators list
    end

let abi_encode_length : Uint32 -> ByStr =
  fun (i : Uint32) =>
    let bz_fixed = builtin to_bystr4 i in
    let bz = builtin to_bystr bz_fixed in
    pad bz u0x20

let append_abi_encoded_length : ByStr -> Uint32 -> ByStr =
  fun (buffer : ByStr) =>
  fun (i : Uint32) =>
    let bz = abi_encode_length i in
    builtin concat buffer bz

let abi_encode_bytes : ByStr -> ByStr =
  fun (bz : ByStr) =>
    let len = builtin strlen bz in
    let len_bz = abi_encode_length len in
    let data_bz = pad_bytes bz in
    builtin concat len_bz data_bz

let abi_encode_u64 : Uint64 -> ByStr =
  fun (num : Uint64) =>
    let bz_8 = builtin to_bystr8 num in
    let bz = builtin to_bystr bz_8 in
    pad bz u0x20

let abi_encode_packed : ByStr -> ByStr -> ByStr =
  fun (first : ByStr) =>
  fun (second : ByStr) =>
    builtin concat first second

let next_offset : Uint32 -> ByStr -> Uint32 =
  fun (current_offset : Uint32) =>
  fun (bz : ByStr) =>
    let len = builtin strlen bz in
    builtin add current_offset len

let encode_tx_param : TxParam -> ByStr =
  fun (tx_param : TxParam) =>
    match tx_param with
    | TxParam txHash crossChainId fromContract toChainId toContract method args =>
      (* tail: data *)
      let t1 = abi_encode_bytes txHash in
      let t2 = abi_encode_bytes crossChainId in
      let t3 = abi_encode_bytes fromContract in
      let t4 = abi_encode_u64 toChainId in
      let t5 = abi_encode_bytes toContract in
      let t6 = abi_encode_bytes method in
      let t7 = abi_encode_bytes args in
      (* compute offsets *)
      let o1 = u0xe0 in (* initial offset of 7 x 32 = 224 bytes used for headers *)
      let o2 = next_offset o1 t1 in
      let o3 = next_offset o2 t2 in
      let o5 = next_offset o3 t3 in
      let o6 = next_offset o5 t5 in
      let o7 = next_offset o6 t6 in
      (* head: offsets *)
      let h1 = abi_encode_length o1 in
      let h2 = append_abi_encoded_length h1 o2 in
      let h3 = append_abi_encoded_length h2 o3 in
      let h4 = builtin concat h3 t4 in (* uint64 is a fixed type *)
      let h5 = append_abi_encoded_length h4 o5 in
      let h6 = append_abi_encoded_length h5 o6 in
      let h7 = append_abi_encoded_length h6 o7 in
      (* combine head to with tail *)
      let c1 = builtin concat h7 t1 in
      let c2 = builtin concat c1 t2 in
      let c3 = builtin concat c2 t3 in
      let c4 = builtin concat c3 t5 in
      let c5 = builtin concat c4 t6 in
      builtin concat c5 t7
    end

let decode_tx_param : ByStr -> TxParam =
  fun (rawParam : ByStr) =>
    (*
      uint offset = 0x20; // accounting for `bytes` prefix, not required for ByStr
      (param.txHash,offset) = rlpGetNextBytes(rawParam, offset);
      (param.crossChainId,offset) = rlpGetNextBytes(rawParam, offset);
      (param.fromContract,offset) = rlpGetNextBytes(rawParam, offset);
      (param.toChainId,offset) = rlpGetNextUint64(rawParam, offset);
      (param.toContract,offset) = rlpGetNextBytes(rawParam, offset);
      (param.method,offset) = rlpGetNextBytes(rawParam, offset);
      (param.args,offset) = rlpGetNextBytes(rawParam, offset);
    *)
    let p1 = rlp_get_next_bytes rawParam u0x00 in match p1 with (* ignore `bytes` prefix *)
    | Pair tx_hash o1 =>
    let p2 = rlp_get_next_bytes rawParam o1 in match p2 with
    | Pair cross_chain_id o2 =>
    let p3 = rlp_get_next_bytes rawParam o2 in match p3 with
    | Pair from_contract o3 =>
    let p4 = rlp_get_next_uint64 rawParam o3 in match p4 with
    | Pair to_chain_id o4 =>
    let p5 = rlp_get_next_bytes rawParam o4 in match p5 with
    | Pair to_contract o5 =>
    let p6 = rlp_get_next_bytes rawParam o5 in match p6 with
    | Pair method o6 =>
    let p7 = rlp_get_next_bytes rawParam o6 in match p7 with
    | Pair args _ =>
    TxParam tx_hash cross_chain_id from_contract to_chain_id to_contract method args
    end end end end end end end

let decode_cross_tx : ByStr -> CrossTx =
  fun (rawTx : ByStr) =>
    (*
      uint offset = 0x20; // account for `bytes` prefix
      (,offset) = rlpReadKind(rawTx, offset);
      bytes memory crossTxParam;
      (crossTx.txHash,offset) = rlpGetNextBytes(rawTx, offset);
      (crossTx.fromChainID,offset) = rlpGetNextUint64(rawTx, offset);
      (crossTxParam,offset) = rlpGetNextBytes(rawTx, offset);
      crossTx.crossTxParam = decodeTxParam(crossTxParam);
    *)
    let p1 = rlp_read_kind rawTx u0x00 in
    let o1 = get_offset p1 in
    let p2 = rlp_get_next_bytes rawTx o1 in match p2 with
    | Pair tx_hash o2 =>
    let p3 = rlp_get_next_uint64 rawTx o2 in match p3 with
    | Pair from_chain_id o3 =>
    let p4 = rlp_get_next_bytes rawTx o3 in match p4 with
    | Pair tx_param_bz _ =>
    let tx_param = decode_tx_param tx_param_bz in
    CrossTx tx_hash from_chain_id tx_param
    end end end

let get_cross_tx_storage_slot : CrossTx -> ByStr =
  fun (crossTx : CrossTx) =>
    let bytes = let temp = 0x72657175657374 in builtin to_bystr temp in
    match crossTx with
    | CrossTx txHash fromChainId txParams =>
      match txParams with
      | TxParam sourceChainTxHash crossChainId fromContract toChainId toContract method args =>
        let encodePacked = let toChainIdByStr8 = builtin to_bystr8 toChainId in
                           let toChainIdBytes = builtin to_bystr toChainIdByStr8 in
                           let toChainIdBytesPadded = right_pad toChainIdBytes u0x08 in
                           let toChaindIdBytesRev = builtin strrev toChainIdBytesPadded in
                           let first = abi_encode_packed bytes toChaindIdBytesRev in abi_encode_packed first txHash in
        let keccak = builtin keccak256hash encodePacked in
        builtin to_bystr keccak
      end
    end

let left_pad_zero : ByStr -> ByStr =
  fun (bytes: ByStr) =>
    let len = builtin strlen bytes in
    let fold = @nat_fold ByStr in
    let fn = fun (cur : ByStr) => fun (num : Nat) =>
      let i = nat_to_int num in
      let idx = let temp = builtin sub len u0x01 in builtin sub temp i in
      let paddedBytes = builtin substr cur u0x00 idx in
      let maybeByteToPad = let fixedByte = builtin substr cur idx u0x01 in builtin to_bystr1 fixedByte in
      match maybeByteToPad with
      | None =>
        (* throw error *)
        let errorCode = Uint32 1010 in
        let err = builtin sub u0x00 errorCode in
        builtin concat padding bytes
      | Some byteToPad =>
        let int = builtin to_uint32 byteToPad in
        let firstHalfByte = builtin div int u0x10 in
        let secondHalfByte = builtin rem int u0x10 in
        let paddedByte4 = let temp = builtin mul firstHalfByte u0x10 in
                          let paddedFirstHalf = builtin mul temp u0x10 in
                          let paddedSecondHalf = builtin add paddedFirstHalf secondHalfByte in builtin to_bystr4 paddedSecondHalf in
        let paddedByte2 = let paddedByteX = builtin to_bystr paddedByte4 in builtin substr paddedByteX u0x02 u0x02 in
        builtin concat cur paddedByte2
      end
    in
    let count = builtin to_nat len in
    let temp = fold fn bytes count in
    let paddedLen = builtin mul len u0x02 in
    builtin substr temp len paddedLen
    
let bytes_to_hex : ByStr -> ByStr = 
  fun (keyBytes: ByStr) =>
    let paddedString = left_pad_zero keyBytes in
    builtin concat paddedString ten_padding

let check_node_hash : ByStr -> Uint32 -> ByStr -> Bool =
  fun (raw: ByStr) =>
  fun (offset: Uint32) =>
  fun (hash: ByStr) =>
    let p = rlp_read_kind raw offset in
    let size = get_size p in
    let offset_ = get_offset p in
    let offsetDiff = builtin sub offset_ offset in
    let fullSize = builtin add size offsetDiff in
    let lt_0x20 = builtin lt fullSize u0x20 in
    match lt_0x20 with
    | True =>
      let subHash = builtin substr hash u0x00 fullSize in
      let subRaw = builtin substr raw u0x00 fullSize in
      let isEqual = builtin eq subHash subRaw in
      match isEqual with
      | True =>
        let hashLen = builtin strlen hash in
        let isHashSameSize = builtin eq hashLen fullSize in
        match isHashSameSize with
        | True => True
        | False => False
        end
      | False => False
      end
    | False =>
      let hashedSum = let substrHashedSum = builtin substr raw offset fullSize in builtin keccak256hash substrHashedSum in
      let paddedHash = pad hash u0x20 in
      let paddedHash20 = builtin to_bystr32 paddedHash in
      match paddedHash20 with
      | None =>
        (* ERR! just blow up here *)
        False
      | Some paddedHash20Fixed =>
        builtin eq hashedSum paddedHash20Fixed
      end
    end

let compact_to_hex : ByStr -> ByStr = 
  fun (keyCompact : ByStr) =>
    let t = builtin substr keyCompact u0x00 u0x01 in
    let maybeTByStr1 = builtin to_bystr1 t in
    match maybeTByStr1 with
    | None =>
      (* throw error *)
      let errorCode = Uint32 1011 in
      let err = builtin sub u0x00 errorCode in
      t
    | Some tByStr1 =>
      let tShifted = let tInt = builtin to_uint32 tByStr1 in builtin div tInt u0x10 in
      let compactLen = builtin strlen keyCompact in
      let isOddValue = builtin rem tShifted u0x02 in
      let isOdd = builtin eq isOddValue u0x01 in
      let hasTermValue = builtin div tShifted u0x02 in
      let hasTerm = builtin eq hasTermValue u0x01 in
      let hexLen = let firstMul = builtin mul compactLen u0x02 in
                         let firstSub = builtin sub firstMul u0x02 in
                         let firstAdd = builtin add firstSub hasTermValue in builtin add firstAdd isOddValue in
      let bytesToPad = let len = builtin sub compactLen u0x01 in builtin substr keyCompact u0x01 len in
      let paddedBytes = left_pad_zero bytesToPad in
      match isOdd with
      | True =>
        let paddedHalfByte = let tInt = builtin to_uint32 tByStr1 in 
                             let secondHalfOfT = builtin rem tInt u0x10 in
                             let paddedHalfByte4 = builtin to_bystr4 secondHalfOfT in
                             let paddedHalfByteX = builtin to_bystr paddedHalfByte4 in builtin substr paddedHalfByteX u0x03 u0x01 in
        let isOddBytes = builtin concat paddedHalfByte paddedBytes in
        match hasTerm with
        | True =>
          let temp = builtin concat isOddBytes ten_padding in
          right_pad temp hexLen
        | False =>
          right_pad isOddBytes hexLen
        end
      | False =>
        match hasTerm with
        | True =>
          let temp = builtin concat paddedBytes ten_padding in
          right_pad temp hexLen
        | False =>
          right_pad paddedBytes hexLen
        end
      end
    end
  
let compare_key : ByStr -> ByStr -> Pair ByStr Bool =
  fun (key : ByStr) =>
  fun (element : ByStr) =>
    let keyLen = builtin strlen key in
    let elementLen = builtin strlen element in
    let keyLenLtElementLen = builtin lt keyLen elementLen in
    match keyLenLtElementLen with
    | True =>
        Pair {ByStr Bool} key false
    | False =>
      let slotCnt = builtin div elementLen u0x20 in
      let remainder = builtin rem elementLen u0x20 in
      let init = True in
      let count = builtin to_nat slotCnt in
      let fold = @nat_fold Bool in
      let fn = fun (cur : Bool) => fun (num : Nat) =>
        let i = nat_to_int num in
        let offset = builtin mul i u0x20 in
        let isLastLoop = builtin eq i slotCnt in
        match isLastLoop with
        | True =>
          let elementExtract = builtin substr element offset remainder in
          let keyExtract = builtin substr key offset remainder in
          builtin eq elementExtract keyExtract
        | False =>
          let elementExtract = builtin substr element offset u0x20 in
          let keyExtract = builtin substr key offset u0x20 in
          builtin eq elementExtract keyExtract
        end
      in
      let forLoopIsIn = fold fn init count in
      let offset = builtin mul slotCnt u0x20 in
      match forLoopIsIn with
      | True =>
        let remainder = builtin rem elementLen u0x20 in
        let elementExtract = builtin substr element offset remainder in
        let keyExtract = builtin substr key offset remainder in
        let isEqual = builtin eq elementExtract keyExtract in
        match isEqual with
        | True =>
          let idx = builtin add offset remainder in
          let remainingKeyLen = builtin sub keyLen idx in
          let keySlice = builtin substr key idx remainingKeyLen in
          Pair {ByStr Bool} keySlice true
        | False =>
          Pair {ByStr Bool} key false
        end
      | False =>
        Pair {ByStr Bool} key false
      end
    end

let take_one_byte : ByStr -> Pair ByStr Uint32 =
  fun (initBuf : ByStr) =>
    let len = builtin strlen initBuf in
    let lenRequired = builtin sub len u0x01 in
    let buf = builtin substr initBuf u0x01 lenRequired in
    let index = builtin substr initBuf u0x00 u0x01 in
    let maybeBufByStr1 = builtin to_bystr1 index in
    match maybeBufByStr1 with
    | None =>
      (* throw error *)
      let errorCode = Uint32 1007 in
      let err = builtin sub u0x00 errorCode in
      Pair {ByStr Uint32} initBuf errorCode
    | Some bufByStr1 =>
      let index = builtin to_uint32 bufByStr1 in
      Pair {ByStr Uint32} buf index
    end

let verify_proof : ByStr -> ByStr -> ByStr -> Pair ByStr Bool =
    fun (initProof : ByStr) =>
    fun (initKey : ByStr) =>
    fun (initRoot : ByStr) =>
      let key = bytes_to_hex initKey in
      let proofSplit = rlp_split initProof u0x00 in
      let proof = get_data proofSplit in
      let value = initRoot in
      let initOffset = u0x00 in
      let initKeyOffsetValue = KeyOffsetValue key initOffset value in
      let size = builtin strlen proof in
      let fold = @nat_fold_while KeyOffsetValue in
      let fn = fun (cur : KeyOffsetValue) => fun (num : Nat) =>
        let i = nat_to_int num in
        let currentValue = get_value cur in
        let currentKey = get_key cur in
        let currentOffset = get_key_offset cur in
        let isOffsetLt = builtin lt currentOffset size in
        match isOffsetLt with
        | False => None {KeyOffsetValue}
        | True =>
          let isEqualNodeHash = check_node_hash proof currentOffset currentValue in
          match isEqualNodeHash with
          | False => 
            (*throw error invalid node hash*)
            let exception_code = Uint32 1008 in
            let err = builtin sub u0x00 exception_code in
            None {KeyOffsetValue}
          | True =>
            let split = rlp_split proof currentOffset in
            let node = get_data split in
            let newOffset = get_split_offset split in
            let tmpReadKind = rlp_read_kind node u0x00 in
            let sizeTmp = get_size tmpReadKind in
            let offsetTmp = get_offset tmpReadKind in
            let tmpReadKind2 = let sum = builtin add sizeTmp offsetTmp in rlp_read_kind node sum in
            let sizeTmp2 = get_size tmpReadKind2 in
            let offsetTmp2 = get_offset tmpReadKind2 in
            let newOffsetTmp = builtin add offsetTmp2 sizeTmp2 in
            let isNewOffsetTmpEqual = let nodeLength = builtin strlen node in builtin eq newOffsetTmp nodeLength in
            match isNewOffsetTmpEqual with
            | True =>
              let trueSplit = rlp_split node u0x00 in
              let keyElement = get_data trueSplit in
              let offset = get_split_offset trueSplit in
              let subKey = compact_to_hex keyElement in
              let compareKey = compare_key currentKey subKey in
              let isIn = get_is_in compareKey in
              match isIn with
              | False =>
                (* throw error here failed CompareKey check*)
                let exception_code = Uint32 1009 in
                let err = builtin sub u0x00 exception_code in
                None {KeyOffsetValue}
              | True => 
                let newKey = get_key_slice compareKey in
                let newSplit = rlp_split node offset in
                let newValue = get_data newSplit in
                let newKeyOffsetValue = KeyOffsetValue newKey newOffset newValue in
                Some {KeyOffsetValue} newKeyOffsetValue
              end
            | False => 
              let currentKeyLength = builtin strlen currentKey in
              let isCurrentKeyLengthZero = builtin eq currentKeyLength u0x00 in
              match isCurrentKeyLengthZero with
              | True =>
                let newKeyOffsetValue = KeyOffsetValue currentKey newOffset currentValue in
                Some {KeyOffsetValue} newKeyOffsetValue
              | False =>
                let takeOneByte = take_one_byte currentKey in
                let newKey = get_buffer takeOneByte in
                let index = get_index takeOneByte in
                let currentOffset_ = u0x00 in
                let init = currentOffset_ in
                let innerFold = @nat_fold_while Uint32 in
                let innerFn = fun (cur : Uint32) => fun (num : Nat) =>
                  let reverse = nat_to_int num in
                  let i = builtin sub u0x11 reverse in
                  let isIndexEqual = builtin eq index i in
                  match isIndexEqual with
                  | True =>
                    None {Uint32}
                  | False =>
                    let currentReadKind = rlp_read_kind node cur in
                    let currentSizeTmp = get_size currentReadKind in
                    let currentOffsetTmp = get_offset currentReadKind in
                    let newOffset_ = builtin add currentSizeTmp currentOffsetTmp in
                    Some {Uint32} newOffset_
                  end
                in
                let innerCount = builtin to_nat u0x11 in
                let finalOffset_ = innerFold innerFn init innerCount in
                let finalSplit = rlp_split node finalOffset_ in
                let newValue = get_data finalSplit in
                let newKeyOffsetValue = KeyOffsetValue newKey newOffset newValue in
                Some {KeyOffsetValue} newKeyOffsetValue
              end
            end
          end
        end
      in
      let maxCount = builtin to_nat u0x20 in
      let keyOffsetValue = fold fn initKeyOffsetValue maxCount in
      let finalValue = get_value keyOffsetValue in
      let finalKey = get_key keyOffsetValue in
      let finalOffset = get_key_offset keyOffsetValue in
      let finalKeyLength = builtin strlen finalKey in
      let isFinalKeyLengthZero = builtin eq finalKeyLength u0x00 in
      match isFinalKeyLengthZero with
      | True =>
        Pair {ByStr Bool} finalValue true
      | False =>
        Pair {ByStr Bool} finalValue false
      end

let verify_account_proof : ByStr -> ByStr -> ByStr20 -> ByStr -> ByStr -> ByStr =
  fun (accountProof : ByStr) =>
  fun (headerRoot : ByStr) =>
  fun (address : ByStr20) =>
  fun (storageProof : ByStr) =>
  fun (storageIndex : ByStr) =>
    (*
        /*
        Account Proof
        -key : keccak256(address[:])
        -val : rlp(state-obj)
        -root : header.Root

        Storage Proof
        -key : keccak256(slot-index) // 32bytes index
        -val : 32 bytes data
        -root : Account.storageHash

        rlp(state-obj) == rlp(Account)
        type Account struct {
          Nonce    uint64
          Balance  *big.Int
          Root     bytes32   // also : storageHash
          CodeHash []byte
        }
        */
            bytes memory _accountKey = _address;
            assembly {
                mstore(add(_accountKey,0x20), keccak256(add(_accountKey, 0x20), mload(_accountKey)))
                mstore(_accountKey, 0x20)
            }
            bytes memory account = verifyProof(_accountProof, _accountKey, _headerRoot);

            // decode state object
            (account,) = rlpSplit(account,0x20);
            (,uint offset) = rlpSplit(account,0x20); // nonce
            (,offset) = rlpSplit(account,offset);    // balance
            (bytes memory storageRoot,) = rlpSplit(account,offset);

            // verify storage proof
            bytes memory _storageKey = _storageIndex;
            assembly {
                mstore(add(_storageKey,0x20), keccak256(add(_storageKey, 0x20), mload(_storageKey)))
                mstore(_storageKey, 0x20)
            }
            value = verifyProof(_storageProof, _storageKey, storageRoot);
            (value,) = rlpSplit(value, 0x20);
        }
    *)
    let account_hash = builtin keccak256hash address in
    let account_key = builtin to_bystr account_hash in
    let verifyAccountProofPair = verify_proof accountProof account_key headerRoot in
    let account = get_verify_proof_value verifyAccountProofPair in
    let get_offset_ = @snd ByStr Uint32 in
    let p1 = rlp_split account u0x00 in
    let d1 = get_data p1 in
    let p2 = rlp_split d1 u0x00 in (* nonce *)
    let o2 = get_offset_ p2 in
    let p3 = rlp_split d1 o2 in (* balance *)
    let o3 = get_offset_ p3 in
    let p4 = rlp_split d1 o3 in
    let storageRoot = get_data p4 in
    let storage_hash = builtin keccak256hash storageIndex in
    let storage_key = builtin to_bystr storage_hash in
    let verifyStorageProofPair = verify_proof storageProof storage_key storageRoot in
    let value = get_verify_proof_value verifyStorageProofPair in
    let r = rlp_split value u0x00 in (* ignore `bytes` prefix *)
    get_data r

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract ZilCrossChainManagerV2(
  initial_owner: ByStr20,
  init_proxy_address: ByStr20,
  eccd: ByStr20 with contract
    field cur_epoch_validators : List ByStr20,
    field cur_epoch_start_height : Uint256,
    field cur_epoch_end_height : Uint256,
    field cur_to_zion_index : Uint256,
    field from_chain_tx_exists : Map Uint64 (Map ByStr32 Bool)
  end
)

field contract_owner : Option ByStr20 = Some {ByStr20} initial_owner
field pending_owner : Option ByStr20 = none

(**************************************)
(*             Procedures             *)
(**************************************)

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsProxy()
  is_proxy = builtin eq _sender init_proxy_address;
  match is_proxy with
  | True  =>
  | False =>
    err = CodeProxyValidationFailed;
    ThrowError err
  end
end

procedure IsNotEmptyVals(vals : List ByStr20)
  is_empty = let l = address_list_length vals in builtin eq l u0x00;
  match is_empty with
  | False => (* ok *)
  | True =>
    err = CodeNoValidatorsInHeader;
    ThrowError err
  end
end

procedure RequireValidToContract(toContract : ByStr20)
  is_proxy = builtin eq toContract init_proxy_address;
  match is_proxy with
  | True =>
    err = CodeInvalidToContract;
    ThrowError err
  | False =>
  end;
  is_eccd = builtin eq toContract eccd;
  match is_eccd with
  | True =>
    err = CodeInvalidToContract;
    ThrowError err
  | False =>
  end;
  is_self = builtin eq toContract _this_address;
  match is_self with
  | True =>
    err = CodeInvalidToContract;
    ThrowError err
  | False =>
  end
end

procedure ExecuteCrossChainTx(
  toContract : ByStr,
  method : ByStr,
  args : ByStr,
  fromContractAddr : ByStr,
  fromChainId : Uint64
)
  r = builtin to_bystr20 toContract;
  match r with
  | None =>
    err = CodeInvalidToContract;
    ThrowError err
  | Some recipient =>
    RequireValidToContract recipient;
    tag = builtin to_ascii method;
    msg_to_recipient =  {
      _tag : tag; _recipient: recipient; _amount: zero_amt;
      args: args; fromContractAddr: fromContractAddr; fromChainId: fromChainId
    };
    msgs = one_msg msg_to_recipient;
    send msgs
  end
end

(**************************************)
(*        Ownership Procedures        *)
(**************************************)

procedure IsOwner(address: ByStr20)
  maybe_current_owner <- contract_owner;
  match maybe_current_owner with
  | Some current_owner =>
    is_owner = builtin eq current_owner address;
    match is_owner with
    | True =>
    | False =>
      err = CodeNotOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotOwner;
    ThrowError err
  end
end

procedure IsPendingOwner(address: ByStr20)
  maybe_pending_owner <- pending_owner;
  match maybe_pending_owner with
  | Some current_pending_owner =>
    is_pending_owner = builtin eq current_pending_owner address;
    match is_pending_owner with
    | True =>
    | False =>
      err = CodeNotPendingOwner;
      ThrowError err
    end
  | None =>
    err = CodeNotPendingOwner;
    ThrowError err
  end
end

(***************************************)
(*             Transitions             *)
(***************************************)

transition InitGenesisBlock(
  rawHeader : ByStr
)
  IsProxy;
  header = decode_header rawHeader;

  (* verify isInit *)
  cur_vals <- & eccd.cur_epoch_validators;
  was_empty = let l = address_list_length cur_vals in builtin eq l u0x00;
  match was_empty with
  | True => (* ok *)
  | False =>
    err = CodeAlreadyInitialized;
    ThrowError err
  end;

  (* get validators and epoch_end_height *)
  epoch_end_vals_pair = get_header_validators_and_epoch_end_height rawHeader;
  match epoch_end_vals_pair with
  | Pair epoch_end_height vals =>
    IsNotEmptyVals vals;

    (* put epoch information *)
    number = get_number header;
    start_height = builtin add one number;
    msg_to_eccd =  {
      _tag : "PutEpochInfo"; _recipient: eccd; _amount: zero_amt;
      epoch_start_height: start_height; epoch_end_height: epoch_end_height; epoch_validators: vals
    };
    msgs = one_msg msg_to_eccd;
    send msgs;

    e = {
      _eventname: "GenesisBlockInitialized";
      number: number; rawHeader: rawHeader
    };
    event e
  end
end

transition ChangeEpoch(
  rawHeader : ByStr,
  rawSeals : ByStr
)
  IsProxy;
  header = decode_header rawHeader;
  number = get_number header;

  (* verify block.height *)
  cur_epoch_start_height <- & eccd.cur_epoch_start_height;
  cur_epoch_end_height <- & eccd.cur_epoch_end_height;
  is_lower = builtin lt number cur_epoch_start_height;
  is_after = builtin lt cur_epoch_end_height number;
  is_invalid = orb is_lower is_after;
  match is_invalid with
  | False => (* ok*)
  | True =>
    err = CodeInvalidBlockHeight;
    ThrowError err
  end;

  (* verify header *)
  epoch_end_new_vals_pair = get_header_validators_and_epoch_end_height rawHeader;
  match epoch_end_new_vals_pair with
  | Pair epoch_end_height new_vals =>
    IsNotEmptyVals new_vals;
    prev_vals <- & eccd.cur_epoch_validators;
    hash = builtin keccak256hash rawHeader;
    ok = verify_header hash rawSeals prev_vals;
    match ok with
    | True => (* ok *)
    | False =>
      err = CodeHeaderVerificationFailed;
      ThrowError err
    end;

    (* put new epoch information *)
    start_height = builtin add one number;
    msg_to_eccd =  {
      _tag : "PutEpochInfo"; _recipient: eccd; _amount: zero_amt;
      epoch_start_height: start_height; epoch_end_height: epoch_end_height; epoch_validators: new_vals
    };
    msgs = one_msg msg_to_eccd;
    send msgs;

    e = {
      _eventname: "EpochChanged";
      number: number; rawHeader: rawHeader; previousValidators: prev_vals; newValidators: new_vals
    };
    event e
  end
end

transition CrossChain(
  toChainId : Uint64,
  toContract : ByStr,
  method : ByStr,
  txData : ByStr
)
  (*
    require(CallerFactory(EthCrossChainCallerFactoryAddress).isChild(msg.sender), "The caller is child of the caller factory!");
    uint256 txHashIndex = IEthCrossChainData(EthCrossChainDataAddress).getEthTxHashIndex();
    bytes memory paramTxHash = ECCUtils.uint256ToBytes(txHashIndex);
    bytes memory crossChainId = abi.encodePacked(sha256(abi.encodePacked(address(this), paramTxHash)));
  *)
  IsProxy;
  idx <- & eccd.cur_to_zion_index;
  idx_bz = let b = builtin to_bystr32 idx in builtin to_bystr b;
  id_bz = let a = builtin to_bystr _this_address in builtin concat a idx_bz;
  cross_chain_id = let hash = builtin keccak256hash id_bz in builtin to_bystr hash;
  sender = builtin to_bystr _sender;
  params = TxParam idx_bz cross_chain_id sender toChainId toContract method txData;
  params_bz = encode_tx_param params;
  tx_hash = builtin keccak256hash params_bz;

  msg_to_eccd =  {
    _tag : "PutTxHash"; _recipient: eccd; _amount: zero_amt;
    tx_hash: tx_hash
  };
  msgs = one_msg msg_to_eccd;
  send msgs;

  (* retaining v1 event format *)
  e = {
    _eventname : "CrossChainEvent";
    sender : _origin;
    txId : idx_bz;
    proxyOrAssetContract : _sender;
    toChainId : toChainId;
    toContract : toContract;
    rawdata : params_bz
  };
  event e
end

transition VerifyHeaderAndExecuteTx(
  rawHeader : ByStr,
  rawSeals : ByStr,
  accountProof : ByStr,
  storageProof : ByStr,
  rawCrossTx : ByStr
)
  IsProxy;
  header = decode_header rawHeader;
  cross_tx = decode_cross_tx rawCrossTx;
  number = get_number header;
  root = get_root header;

  (* verify block.height *)
  cur_epoch_start_height <- & eccd.cur_epoch_start_height;
  cur_epoch_end_height <- & eccd.cur_epoch_end_height;
  is_lower = builtin lt number cur_epoch_start_height;
  is_after = builtin lt cur_epoch_end_height number;
  is_invalid = orb is_lower is_after;
  match is_invalid with
  | False => (* ok*)
  | True =>
    err = CodeInvalidBlockHeight;
    ThrowError err
  end;

  (* verify header *)
  prev_vals <- & eccd.cur_epoch_validators;
  hash = builtin keccak256hash rawHeader;
  ok = verify_header hash rawSeals prev_vals;
  match ok with
  | True => (* ok *)
  | False =>
    err = CodeHeaderVerificationFailed;
    ThrowError err
  end;

  (*
    bytes memory storageIndex = ECCUtils.getCrossTxStorageSlot(crossTx);
    bytes memory storageValue = ECCUtils.verifyAccountProof(accountProof, header.root, ZionCrossChainManagerAddress, storageProof, storageIndex);
    require(ECCUtils.bytesToBytes32(storageValue) == keccak256(rawCrossTx), "Verify proof failed");
  *)

  storage_index = get_cross_tx_storage_slot cross_tx;
  storage_value = verify_account_proof accountProof root zion_ccm_address storageProof storage_index;
  keccakCrossTx = builtin keccak256hash rawCrossTx;
  maybe_storage_value_bystr32 = builtin to_bystr32 storage_value;
  match maybe_storage_value_bystr32 with
  | Some storage_value_bystr32 =>
    isEqual = builtin eq keccakCrossTx storage_value_bystr32;
    match isEqual with
    | True =>
    | False =>
      err = CodeVerifyProofFailed;
      ThrowError err
    end
  | None =>
    err = CodeVerifyProofFailed;
    ThrowError err
  end;

  match cross_tx with
  | CrossTx tx_hash from_chain_id tx_param =>
    (* check & put tx exection information *)
    t = builtin to_bystr32 tx_hash;
    match t with
    | Some tx_hash_fixed =>
      e <- & eccd.from_chain_tx_exists[from_chain_id][tx_hash_fixed];
      match e with
      | None => (* ok *)
      | Some _ =>
        err = CodeTxAlreadyExecuted;
        ThrowError err
      end;
      match tx_param with
      | TxParam from_tx_hash cross_chain_id from_contract to_chain_id to_contract method args =>
        is_right_chain = builtin eq zilliqa_chain_id to_chain_id;
        match is_right_chain with
        | True => (* ok *)
        | False =>
          err = CodeInvalidToChainID;
          ThrowError err
        end;

        maybe_from_tx_hash_fixed = builtin to_bystr32 from_tx_hash;

        match maybe_from_tx_hash_fixed with
        | None =>
          err = CodeInvalidToChainID;
          ThrowError err
        | Some from_tx_hash_fixed =>
          msg_to_eccd =  {
            _tag : "MarkTxExecuted"; _recipient: eccd; _amount: zero_amt;
            from_chain_id: from_chain_id; from_tx_hash: tx_hash_fixed
          };
          msgs = one_msg msg_to_eccd;
          send msgs
        end;

        ExecuteCrossChainTx to_contract method args from_contract from_chain_id;

        (* retain v1 events *)
        e = {
          _eventname: "VerifyHeaderAndExecuteTxEvent";
          fromChainId : from_chain_id;
          toContractAddr : to_contract;
          crossChainTxHash : tx_hash;
          fromChainTxHash : from_tx_hash
        };
        event e
      end
    | None =>
      err = CodeInvalidTxHash;
      ThrowError err
    end
  end
end

(***************************************************)
(*              Ownership Transitions              *)
(***************************************************)

(* @dev: Transfers contract ownership to a new address. The new address must call the AcceptOwnership transition to finalize the transfer. *)
(* @param new_owner: Address of the new contract_owner.                                                                                    *)
transition TransferOwnership(new_owner: ByStr20)
  IsOwner _sender;
  o = Some {ByStr20} new_owner;
  pending_owner := o;
  e = {_eventname : "OwnershipTransferInitiated"; contract_owner : _sender; pending_owner : new_owner};
  event e
end

(* @dev: Finalizes transfer of contract ownership. Must be called by the new contract_owner. *)
transition AcceptOwnership()
  IsPendingOwner _sender;
  previous_contract_owner <- contract_owner;
  o = Some {ByStr20} _sender;
  contract_owner := o;
  pending_owner := none;
  e = {_eventname : "OwnershipTransferAccepted"; previous_contract_owner : previous_contract_owner; contract_owner : _sender};
  event e
end
